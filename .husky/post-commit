#!/bin/sh
# Exit on error
set -e

echo "üìä POST-COMMIT REPORT"
echo "===================="

# Get current branch name (with error handling)
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown-branch")

# Get the last commit message (with error handling)
COMMIT_MSG=$(git log -1 --pretty=%B 2>/dev/null || echo "unknown-commit")

# Start collecting results to a variable for a clean report
OUTPUT=""

# Use git ls-files to respect .gitignore and only find js/html files over 1000 lines
OUTPUT="${OUTPUT}\nüîç LARGE FILES (>1000 lines, JS/HTML only):\n"
git ls-files "*.js" "*.html" 2>/dev/null | xargs wc -l 2>/dev/null | awk '$1 > 1000 {print "üìÑ " $1 " lines: " substr($0, index($0, $2))}' | sort -nr | head -10 > /tmp/large_files.txt 2>/dev/null || touch /tmp/large_files.txt
LARGE_FILES=$(cat /tmp/large_files.txt 2>/dev/null || echo "")
LARGE_FILES_COUNT=$(wc -l < /tmp/large_files.txt 2>/dev/null | tr -d ' ' || echo "0")

if [ "$LARGE_FILES_COUNT" -gt 0 ]; then
  OUTPUT="${OUTPUT}${LARGE_FILES}"
  if [ "$LARGE_FILES_COUNT" -gt 10 ]; then
    OUTPUT="${OUTPUT}\n...and $(($LARGE_FILES_COUNT - 10)) more files over 1000 lines"
  fi
else
  OUTPUT="${OUTPUT}‚úÖ No large JS or HTML files found"
fi

# Print the output collected so far - use printf instead of echo -e
printf "%b\n" "$OUTPUT"

# Run the test-version script to get version changes
VERSION_OUTPUT=$(pnpm version:check 2>&1 || echo "No version data available")

# Check if version changes are detected and add to the end of the report
printf "\n====================\n"

echo "üì¶ VERSION IMPACT:"

# Load commit types from files (generated by commitlint.config.cjs)
HUSKY_DIR=$(dirname "$0")
ALLOWED_TYPES=$(cat "$HUSKY_DIR/.commit-types" 2>/dev/null || echo "build chore ci docs feat fix perf refactor revert style test slice")
VERSIONING_TYPES=$(cat "$HUSKY_DIR/.versioning-types" 2>/dev/null || echo "feat fix perf slice")
# Load ignored scopes
IGNORED_SCOPES=$(cat "$HUSKY_DIR/.ignore-scopes" 2>/dev/null || echo "pipeline")

# Build regex pattern for extracting type
TYPES_PATTERN=$(echo "$ALLOWED_TYPES" | sed 's/ /|/g')

# Determine version bump based on commit type
COMMIT_TYPE=$(echo "$COMMIT_MSG" | grep -oE "^(${TYPES_PATTERN})(\([^)]+\))?!?:" 2>/dev/null | grep -oE "^[^(:!]+" 2>/dev/null || echo "unknown")
BREAKING=$(echo "$COMMIT_MSG" | grep -E "^[^:]+!:" -c 2>/dev/null || echo "0")
BREAKING_BODY=$(echo "$COMMIT_MSG" | grep -E "BREAKING CHANGE:" -c 2>/dev/null || echo "0")

# Extract the scope from the commit message if it exists
COMMIT_SCOPE=$(echo "$COMMIT_MSG" | grep -oE "^[^(]+\(([^)]+)\)" 2>/dev/null | sed -E 's/^[^(]+\(([^)]+)\)/\1/' 2>/dev/null || echo "")

# Check if the scope is in the ignored scopes list
SCOPE_IGNORED=0
if [ -n "$COMMIT_SCOPE" ]; then
  for ignored_scope in $IGNORED_SCOPES; do
    if [ "$COMMIT_SCOPE" = "$ignored_scope" ]; then
      SCOPE_IGNORED=1
      break
    fi
  done
fi

# Only calculate version impact if scope is not ignored
if [ "$SCOPE_IGNORED" -eq 0 ]; then
  if [ "$BREAKING" -gt 0 ] || [ "$BREAKING_BODY" -gt 0 ]; then
    BUMP="+1.0.0"
    BUMP_COLOR="\033[31m" # Red
    BUMP_TYPE="major"
  elif [ "$COMMIT_TYPE" = "feat" ]; then
    BUMP="+0.1.0"
    BUMP_COLOR="\033[33m" # Yellow
    BUMP_TYPE="minor"
  elif echo "$VERSIONING_TYPES" | grep -q "\b$COMMIT_TYPE\b"; then
    BUMP="+0.0.1"
    BUMP_COLOR="\033[36m" # Cyan
    BUMP_TYPE="patch"
  else
    # Non-versioning commit type
    BUMP=""
    BUMP_COLOR=""
    BUMP_TYPE="none"
  fi
else
  # Scope is ignored
  BUMP=""
  BUMP_COLOR=""
  BUMP_TYPE="none"
fi

# Define the magenta color for the version bump display
MAGENTA="\033[35m"
RESET="\033[0m"

# Check if version changes are detected
if echo "$VERSION_OUTPUT" | grep -q "Version Changes:" 2>/dev/null; then
  # Extract package names to check if scope is valid (safely)
  PACKAGE_NAMES=$(echo "$VERSION_OUTPUT" | awk '/Version Changes:/,/^$/ {if (!/Version Changes:/ && !/^$/ && NF > 0) print $1}' 2>/dev/null | sed 's/://' 2>/dev/null || echo "")
  
  # Flag to determine if scope is valid
  SCOPE_IS_VALID=0
  
  # If no scope is provided, it applies to all packages
  if [ -z "$COMMIT_SCOPE" ]; then
    SCOPE_IS_VALID=1
  else
    # Check if scope matches any package name
    for pkg in $PACKAGE_NAMES; do
      if echo "$pkg" | grep -q "$COMMIT_SCOPE" 2>/dev/null || echo "$COMMIT_SCOPE" | grep -q "$pkg" 2>/dev/null; then
        SCOPE_IS_VALID=1
        break
      fi
    done
  fi
  
  # Only show the version bump if the scope is valid, not ignored, and there's a bump to show
  if [ "$SCOPE_IS_VALID" -eq 1 ] && [ "$SCOPE_IGNORED" -eq 0 ] && [ -n "$BUMP" ]; then
    # Use magenta for commit message (not blue or green) and show the bump
    echo -e "‚úÖ Accepted commit message: \033[35m\"${COMMIT_MSG}\"\033[0m ${BUMP_COLOR}${BUMP}\033[0m (${BUMP_TYPE})"
  else
    # Show the commit message but no bump since the scope doesn't affect any package
    echo -e "‚úÖ Accepted commit message: \033[35m\"${COMMIT_MSG}\"\033[0m (no version impact)"
  fi
  
  # Create a temporary file to store the modified version output
  TMP_VERSION_OUTPUT="/tmp/version_output.txt"
  touch "$TMP_VERSION_OUTPUT" 2>/dev/null
  
  # If we have a valid scope that matches a package and it's not ignored
  if [ -n "$COMMIT_SCOPE" ] && [ "$SCOPE_IS_VALID" -eq 1 ] && [ "$SCOPE_IGNORED" -eq 0 ] && [ -n "$BUMP" ]; then
    # Process the version output and add the version bump to the matching package
    echo "$VERSION_OUTPUT" | awk -v scope="$COMMIT_SCOPE" -v bump="$BUMP" -v magenta="$MAGENTA" -v reset="$RESET" '
    /Version Changes:/,/^$/ {
      if (!/Version Changes:/ && !/^$/) {
        if ($1 ~ scope || scope ~ $1) {
          print $0 " " magenta bump reset
        } else {
          print $0
        }
      } else {
        print $0
      }
    }' > "$TMP_VERSION_OUTPUT" 2>/dev/null || echo "$VERSION_OUTPUT" > "$TMP_VERSION_OUTPUT"
  # If we have no scope and it's a versioning commit type
  elif [ -z "$COMMIT_SCOPE" ] && [ -n "$BUMP" ]; then
    # No scope found, apply bump to all packages
    echo "$VERSION_OUTPUT" | awk -v bump="$BUMP" -v magenta="$MAGENTA" -v reset="$RESET" '
    /Version Changes:/,/^$/ {
      if (!/Version Changes:/ && !/^$/ && NF > 0) {
        print $0 " " magenta bump reset
      } else {
        print $0
      }
    }' > "$TMP_VERSION_OUTPUT" 2>/dev/null || echo "$VERSION_OUTPUT" > "$TMP_VERSION_OUTPUT"
  # Otherwise, just show the original output with no bumps
  else
    echo "$VERSION_OUTPUT" | awk '/Version Changes:/,/^$/ {print}' > "$TMP_VERSION_OUTPUT" 2>/dev/null || echo "$VERSION_OUTPUT" > "$TMP_VERSION_OUTPUT"
  fi
    
  # Display the modified output if the file exists
  if [ -f "$TMP_VERSION_OUTPUT" ]; then
    cat "$TMP_VERSION_OUTPUT" 2>/dev/null || echo "$VERSION_OUTPUT"
  else
    echo "$VERSION_OUTPUT"
  fi
else
  # Still show the commit message even if there are no version changes
  if [ -n "$COMMIT_TYPE" ] && [ "$COMMIT_TYPE" != "unknown" ] && [ "$SCOPE_IGNORED" -eq 0 ] && [ -n "$BUMP" ]; then
    echo -e "‚úÖ Accepted commit message: \033[35m\"${COMMIT_MSG}\"\033[0m ${BUMP_COLOR}${BUMP}\033[0m (${BUMP_TYPE})"
  else
    if [ "$SCOPE_IGNORED" -eq 1 ]; then
      echo -e "‚úÖ Accepted commit message: \033[35m\"${COMMIT_MSG}\"\033[0m (scope 'pipeline' ignored for versioning)"
    else
      echo -e "‚úÖ Accepted commit message: \033[35m\"${COMMIT_MSG}\"\033[0m (no version impact)"
    fi
  fi
  
  echo "‚ÑπÔ∏è No version changes detected from this commit."
fi

echo "===================="

# Always exit with success to avoid breaking the commit process
exit 0 