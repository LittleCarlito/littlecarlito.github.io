#!/bin/bash
# Running pre-push checks directly without husky sourcing

# Change to repository root directory to ensure commands work correctly
cd "$(git rev-parse --show-toplevel)" || exit 1

echo "üîç Running pre-push checks..."

# First, verify the lockfile is in sync with package.json
echo "Verifying lockfile integrity..."
# Check if lockfile is out of sync using pnpm's lockfile-report
pnpm install --frozen-lockfile --prefer-offline --lockfile-only > /dev/null 2>&1
LOCKFILE_STATUS=$?

if [ $LOCKFILE_STATUS -ne 0 ]; then
    echo "‚ö†Ô∏è Lockfile is out of sync with package.json."
    echo "üîß Automatically updating lockfile..."
    
    # Update lockfile
    pnpm install --no-frozen-lockfile
    
    # Commit the changes
    git add pnpm-lock.yaml
    git commit -m "chore: update lockfile to match package.json"
    
    echo "‚úÖ Lockfile updated and changes committed! Continuing with push..."
else
    echo "‚úÖ Lockfile is in sync with package.json"
fi

# Check for changes outside development/ and public/ directories
echo "Checking for relevant file changes..."

# Get files changed between base commit and HEAD
CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)

# Flag to indicate if we need to run tests
RUN_TESTS=false

# Use a different approach to avoid subshell issues
for file in $CHANGED_FILES; do
    # Skip empty lines
    [ -z "$file" ] && continue
    
    # Check if file is NOT in development/ or public/ directories
    if ! [[ "$file" =~ ^(development/|public/) ]]; then
        echo "üîç Found change in $file - will run pipeline tests"
        RUN_TESTS=true
    fi
done

if [ "$RUN_TESTS" = true ]; then
    # Check if .github directory has changes
    GITHUB_DIR_CHANGES=$(git diff --name-only HEAD^ HEAD | grep -c "^\.github/")
    
    # Only run workflow validation if .github directory has changes
    if [ "$GITHUB_DIR_CHANGES" -gt 0 ]; then
        echo "üîç Changes detected in .github directory, validating workflows..."
        
        # Run the new validation script
        if [ -f "tests/pipeline-tests/validate-github-actions.sh" ]; then
            echo "Running GitHub Actions validator..."
            ./tests/pipeline-tests/validate-github-actions.sh || {
                echo "‚ùå GitHub Actions validation failed."
                echo "Please fix workflow syntax issues before pushing."
                exit 1
            }
        fi
        
        # Also run existing workflow alignment validator if available
        if [ -f ".github/scripts/pr/validate-workflow-alignment.sh" ]; then
            echo "Running workflow alignment validation..."
            ./.github/scripts/pr/validate-workflow-alignment.sh || {
                echo "‚ùå Workflow alignment validation failed."
                echo "Please fix workflow alignment issues before pushing."
                exit 1
            }
        else
            echo "‚ö†Ô∏è Workflow alignment script not found at .github/scripts/pr/validate-workflow-alignment.sh"
            echo "Skipping workflow alignment validation."
        fi
    else
        echo "‚úÖ No changes in .github directory, skipping workflow validation."
    fi
    
    # Run unified pipeline with logging
    echo "üöÄ Running unified pipeline test with full logging..."
    pnpm test
    TEST_STATUS=$?
    echo "Test command exited with status: $TEST_STATUS"
    
    if [ $TEST_STATUS -ne 0 ]; then
        echo "‚ùå Pipeline test failed. See output above for details."
        exit 1
    fi
    
    # Explicitly indicate tests passed
    echo "‚úÖ Pipeline tests passed! Moving to build step..."

    # Run build to ensure it succeeds
    echo "üèóÔ∏è Running build..."
    pnpm build
    BUILD_STATUS=$?
    echo "Build command exited with status: $BUILD_STATUS"
    
    if [ $BUILD_STATUS -ne 0 ]; then
        echo "‚ùå Build failed. Please fix build issues before pushing."
        exit 1
    fi
    echo "‚úÖ Build passed!"
    
    # Check if there are any changeset files to consume
    CHANGESET_COUNT=$(find .changeset -name "*.md" -not -name "README.md" -not -name "config.json" | wc -l | tr -d ' ')
    
    if [ "$CHANGESET_COUNT" -gt 0 ]; then
        echo "üì¶ Found $CHANGESET_COUNT changesets to consume."
        
        # Create a temporary branch to work on in case we need to abort
        CURRENT_BRANCH=$(git symbolic-ref --short HEAD)
        TEMP_BRANCH="temp-changeset-version-$(date +%s)"
        
        echo "Creating temporary branch $TEMP_BRANCH to safely process changesets..."
        git checkout -b "$TEMP_BRANCH"
        
        # Run changeset version to consume changesets and bump versions
        echo "üìà Running changeset version to bump package versions..."
        pnpm changeset version
        VERSION_STATUS=$?
        
        if [ $VERSION_STATUS -ne 0 ]; then
            echo "‚ùå Changeset version failed. Reverting changes and aborting push."
            git checkout "$CURRENT_BRANCH"
            git branch -D "$TEMP_BRANCH"
            exit 1
        fi
        
        # Collect updated package information for tags
        echo "üìã Collecting updated package information for tags..."
        # Store package paths and new versions in arrays
        PACKAGE_PATHS=()
        PACKAGE_NAMES=()
        PACKAGE_VERSIONS=()
        
        # Collect packages from packages/ directory
        for PKG_DIR in packages/*; do
            if [ -d "$PKG_DIR" ] && [ -f "$PKG_DIR/package.json" ]; then
                PKG_PATH="$PKG_DIR"
                PKG_NAME=$(grep -m 1 '"name":' "$PKG_DIR/package.json" | sed 's/.*"name": "\(.*\)".*/\1/')
                PKG_VERSION=$(grep -m 1 '"version":' "$PKG_DIR/package.json" | sed 's/.*"version": "\(.*\)".*/\1/')
                
                PACKAGE_PATHS+=("$PKG_PATH")
                PACKAGE_NAMES+=("$PKG_NAME")
                PACKAGE_VERSIONS+=("$PKG_VERSION")
            fi
        done
        
        # Collect packages from apps/ directory
        for APP_DIR in apps/*; do
            if [ -d "$APP_DIR" ] && [ -f "$APP_DIR/package.json" ]; then
                APP_PATH="$APP_DIR"
                APP_NAME=$(grep -m 1 '"name":' "$APP_DIR/package.json" | sed 's/.*"name": "\(.*\)".*/\1/')
                APP_VERSION=$(grep -m 1 '"version":' "$APP_DIR/package.json" | sed 's/.*"version": "\(.*\)".*/\1/')
                
                PACKAGE_PATHS+=("$APP_PATH")
                PACKAGE_NAMES+=("$APP_NAME")
                PACKAGE_VERSIONS+=("$APP_VERSION")
            fi
        done
        
        # Commit the version changes
        echo "üíæ Committing version changes..."
        git add .
        git commit -m "chore(pipeline): version packages"
        COMMIT_STATUS=$?
        
        if [ $COMMIT_STATUS -ne 0 ]; then
            echo "‚ùå Failed to commit version changes. Reverting changes and aborting push."
            git checkout "$CURRENT_BRANCH"
            git branch -D "$TEMP_BRANCH"
            exit 1
        fi
        
        # Create tags for each updated package
        echo "üè∑Ô∏è Creating tags for updated packages..."
        for i in "${!PACKAGE_NAMES[@]}"; do
            TAG_NAME="${PACKAGE_NAMES[$i]}@${PACKAGE_VERSIONS[$i]}"
            echo "Creating tag $TAG_NAME"
            git tag -a "$TAG_NAME" -m "Release ${PACKAGE_NAMES[$i]} version ${PACKAGE_VERSIONS[$i]}"
        done
        
        # Everything looks good, merge back to the original branch
        echo "üîÑ Merging changes back to $CURRENT_BRANCH..."
        git checkout "$CURRENT_BRANCH"
        git merge --no-ff "$TEMP_BRANCH" -m "chore(pipeline): merge version changes"
        MERGE_STATUS=$?
        
        # Clean up temp branch regardless of merge status
        git branch -D "$TEMP_BRANCH"
        
        if [ $MERGE_STATUS -ne 0 ]; then
            echo "‚ùå Failed to merge version changes. Aborting push."
            echo "Please resolve any merge conflicts and try again."
            exit 1
        fi
        
        echo "‚úÖ Successfully versioned packages, created tags, and committed changes!"
    else
        echo "‚ÑπÔ∏è No changesets found to consume. Skipping version bump."
    fi
    
    echo "‚úÖ All pre-push checks completed successfully!"
else
    echo "‚úÖ No changes detected outside development/ and public/ directories. Skipping tests."
fi

echo "üéâ Pre-push checks completed successfully!"
exit 0 