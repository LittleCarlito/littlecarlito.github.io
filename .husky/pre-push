#!/usr/bin/env bash
# Running pre-push checks directly without husky sourcing

# Detect if this is a recursive call from our own script
if [ -n "${HUSKY_PUSH_RUNNING}" ]; then
  echo "‚úÖ Detected push from our own script, skipping pre-push hook"
  exit 0
fi

# Set environment variable to mark that we're running
export HUSKY_PUSH_RUNNING=1

# Capture original args
ARGS=("$@")

# Source the shared checks script
source "$(dirname "$0")/_pre-push-checks.sh"

# If we reach here, all checks passed. Now handle the actual push
# with proper tag handling based on the checks that were run

PUSH_CMD="git push"
if [ "$PUSH_TAGS" = "true" ] && [ -n "$PUSH_WITH_TAGS" ]; then
  PUSH_CMD="$PUSH_CMD --tags"
fi

# Add the original arguments
for arg in "${ARGS[@]}"; do
  PUSH_CMD="$PUSH_CMD $arg"
done

# Execute the push with our environment variable to prevent recursion
echo "üöÄ Running: $PUSH_CMD"
eval "HUSKY_PUSH_RUNNING=1 $PUSH_CMD"
PUSH_STATUS=$?

if [ $PUSH_STATUS -ne 0 ]; then
  echo "‚ùå Push failed with status $PUSH_STATUS"
  exit $PUSH_STATUS
fi

echo "‚úÖ Push completed successfully!"

# Exit with 0 which tells Git not to do its own push
exit 0 