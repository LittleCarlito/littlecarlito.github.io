#!/bin/bash
# Running pre-push checks directly without husky sourcing

# Set -e is removed to prevent silent exits
# Instead we'll explicitly handle errors and provide better logging

# Add debugging
# set -x

# Parse command-line arguments
DRY_RUN=false
PUSH_TAGS=true

# Check for command-line arguments
for arg in "$@"; do
  if [ "$arg" = "--dry-run" ]; then
    DRY_RUN=true
    echo "üî¨ DRY RUN MODE ENABLED - No changes will be committed or pushed"
  fi
  if [ "$arg" = "--no-tags" ]; then
    PUSH_TAGS=false
    echo "üè∑Ô∏è TAGS WILL NOT BE PUSHED"
  fi
done

# Check if we should skip tests
SKIP_TESTS=${SKIP_TESTS:-false}
if [ "$SKIP_TESTS" = "true" ]; then
  echo "‚è© SKIPPING TESTS"
fi

# Change to repository root directory to ensure commands work correctly
cd "$(git rev-parse --show-toplevel)" || {
    echo "‚ùå Failed to change to repository root directory"
    exit 1
}

echo "üîç Running pre-push checks..."

# First, verify the lockfile is in sync with package.json
echo "Verifying lockfile integrity..."
# Check if lockfile is out of sync using pnpm's lockfile-report
pnpm install --frozen-lockfile --prefer-offline --lockfile-only > /dev/null 2>&1
LOCKFILE_STATUS=$?

if [ $LOCKFILE_STATUS -ne 0 ]; then
    echo "‚ö†Ô∏è Lockfile is out of sync with package.json."
    if [ "$DRY_RUN" = true ]; then
        echo "üî¨ [DRY RUN] Would update lockfile and commit changes"
    else
        echo "üîß Automatically updating lockfile..."
        
        # Update lockfile
        pnpm install --no-frozen-lockfile
        
        # Commit the changes
        git add pnpm-lock.yaml
        git commit -m "chore: update lockfile to match package.json"
        
        echo "‚úÖ Lockfile updated and changes committed! Continuing with push..."
    fi
else
    echo "‚úÖ Lockfile is in sync with package.json"
fi

# Check if there are uncommitted package version changes
echo "Checking for uncommitted package version changes..."
UNCOMMITTED_VERSIONS=$(git diff --name-only --diff-filter=M -- "**/package.json" | wc -l)
if [ "$UNCOMMITTED_VERSIONS" -gt 0 ]; then
    echo "‚ö†Ô∏è Found uncommitted package version changes in package.json file(s)"
    git diff --name-only --diff-filter=M -- "**/package.json"
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        echo "üî¨ [DRY RUN] Would run automatic versioning"
    else
        echo "üè∑Ô∏è Running full versioning with tag creation..."
        # Run lerna version with tag creation for all branches
        # Use the ignore-scripts flag to avoid running the version script from package.json
        pnpm version:local-tags
        
        # Re-stage any changes made by lerna
        git add .
        git commit -m "chore(release): publish [skip ci]" || echo "No changes to commit"
        
        echo "‚úÖ Versioning completed! Tags created before push."
        
        # Set flag to push with tags
        PUSH_WITH_TAGS=true
    fi
fi

# Check if we should push tags with this branch
CURRENT_BRANCH=$(git symbolic-ref --short HEAD)
if [ "$PUSH_TAGS" = true ]; then
    # Check if there are any local tags that aren't on the remote
    LOCAL_ONLY_TAGS=$(git tag -l --points-at HEAD | wc -l | tr -d '[:space:]')
    
    if [ "$LOCAL_ONLY_TAGS" -gt 0 ]; then
        echo "üè∑Ô∏è Found $LOCAL_ONLY_TAGS local tag(s) for the current commit"
        git tag -l --points-at HEAD
        
        if [ "$DRY_RUN" = true ]; then
            echo "üî¨ [DRY RUN] Would push branch with tags"
        else
            echo "üöÄ Pushing branch $CURRENT_BRANCH with tags..."
            # Modify git push command to include --follow-tags
            # This will be executed later in the script (or by Git)
            PUSH_WITH_TAGS=true
        fi
    else
        echo "‚úÖ No new tags to push"
    fi
else
    echo "‚è© Tag pushing is disabled, only pushing branch"
fi

# Check for changes outside development/ and public/ directories
echo "Checking for relevant file changes..."

# Get files changed between base commit and HEAD
CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
if [ $? -ne 0 ]; then
    echo "‚ùå Error getting changed files. This might happen if you're pushing a new branch."
    echo "Proceeding with tests to be safe..."
    RUN_TESTS=true
else
    # Flag to indicate if we need to run tests
    RUN_TESTS=false

    # Use a different approach to avoid subshell issues
    for file in $CHANGED_FILES; do
        # Skip empty lines
        [ -z "$file" ] && continue
        
        # Check if file is NOT in development/ or public/ directories
        if ! [[ "$file" =~ ^(development/|public/) ]]; then
            echo "üîç Found change in $file - will run pipeline tests"
            RUN_TESTS=true
        fi
    done
fi

# Set RUN_TESTS to false if SKIP_TESTS is true
if [ "$SKIP_TESTS" = "true" ]; then
    RUN_TESTS=false
    echo "‚è© Test execution has been skipped due to SKIP_TESTS=true flag"
fi

if [ "$RUN_TESTS" = true ]; then
    # Check if .github directory has changes
    GITHUB_DIR_CHANGES=$(git diff --name-only HEAD^ HEAD 2>/dev/null | grep -c "^\.github/" || echo "0")
    
    # Only run workflow validation if .github directory has changes
    if [ "$GITHUB_DIR_CHANGES" -gt 0 ]; then
        echo "üîç Changes detected in .github directory, validating workflows..."
        
        # Run the new validation script
        if [ -f "tests/pipeline-tests/validate-github-actions.sh" ]; then
            echo "Running GitHub Actions validator..."
            ./tests/pipeline-tests/validate-github-actions.sh || {
                echo "‚ùå GitHub Actions validation failed."
                echo "Please fix workflow syntax issues before pushing."
                exit 1
            }
        fi
        
        # Also run existing workflow alignment validator if available
        if [ -f ".github/scripts/pr/validate-workflow-alignment.sh" ]; then
            echo "Running workflow alignment validation..."
            ./.github/scripts/pr/validate-workflow-alignment.sh || {
                echo "‚ùå Workflow alignment validation failed."
                echo "Please fix workflow alignment issues before pushing."
                exit 1
            }
        else
            echo "‚ö†Ô∏è Workflow alignment script not found at .github/scripts/pr/validate-workflow-alignment.sh"
            echo "Skipping workflow alignment validation."
        fi
    else
        echo "‚úÖ No changes in .github directory, skipping workflow validation."
    fi
    
    # Run unified pipeline with logging
    echo "üöÄ Running unified pipeline test with full logging..."
    pnpm test
    TEST_STATUS=$?
    echo "Test command exited with status: $TEST_STATUS"
    
    if [ $TEST_STATUS -ne 0 ]; then
        echo "‚ùå Pipeline test failed. See output above for details."
        exit 1
    fi
    
    # Explicitly indicate tests passed
    echo "‚úÖ Pipeline tests passed! Moving to build step..."

    # Run build to ensure it succeeds
    echo "üèóÔ∏è Running build..."
    pnpm build
    BUILD_STATUS=$?
    echo "Build command exited with status: $BUILD_STATUS"
    
    if [ $BUILD_STATUS -ne 0 ]; then
        echo "‚ùå Build failed. Please fix build issues before pushing."
        exit 1
    fi
    echo "‚úÖ Build passed!"
fi

if [ "$DRY_RUN" = true ]; then
    echo "üî¨ DRY RUN COMPLETED - No actual changes were made"
    echo "Run without the --dry-run flag to apply these changes when pushing"
else
    # If we need to push with tags, we'll do it here
    if [ "$PUSH_WITH_TAGS" = true ]; then
        echo "üöÄ Pushing branch with tags..."
        # This command executes a push with the --follow-tags flag
        # Note: This needs to be changed if you want to push to a specific remote and branch
        exec git push --follow-tags "${@:2}"
        # Exit code will be the status of the git push command
    else
        echo "üéâ Pre-push checks completed successfully!"
    fi
fi

# Exit with success in dry run mode
if [ "$DRY_RUN" = true ]; then
    exit 0
fi

exit 0 