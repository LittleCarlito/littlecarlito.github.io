#!/bin/bash
# Running pre-push checks directly without husky sourcing

# Set -e is removed to prevent silent exits
# Instead we'll explicitly handle errors and provide better logging

# Add debugging
# set -x

# Parse command-line arguments
DRY_RUN=false

# Check if --dry-run flag is provided
for arg in "$@"; do
  if [ "$arg" = "--dry-run" ]; then
    DRY_RUN=true
    echo "🔬 DRY RUN MODE ENABLED - No changes will be committed or pushed"
    break
  fi
done

# Check if we should skip tests
SKIP_TESTS=${SKIP_TESTS:-false}
if [ "$SKIP_TESTS" = "true" ]; then
  echo "⏩ SKIPPING TESTS - Only checking version bumps and changesets"
fi

# Change to repository root directory to ensure commands work correctly
cd "$(git rev-parse --show-toplevel)" || {
    echo "❌ Failed to change to repository root directory"
    exit 1
}

echo "🔍 Running pre-push checks..."

# First, verify the lockfile is in sync with package.json
echo "Verifying lockfile integrity..."
# Check if lockfile is out of sync using pnpm's lockfile-report
pnpm install --frozen-lockfile --prefer-offline --lockfile-only > /dev/null 2>&1
LOCKFILE_STATUS=$?

if [ $LOCKFILE_STATUS -ne 0 ]; then
    echo "⚠️ Lockfile is out of sync with package.json."
    if [ "$DRY_RUN" = true ]; then
        echo "🔬 [DRY RUN] Would update lockfile and commit changes"
    else
        echo "🔧 Automatically updating lockfile..."
        
        # Update lockfile
        pnpm install --no-frozen-lockfile
        
        # Commit the changes
        git add pnpm-lock.yaml
        git commit -m "chore: update lockfile to match package.json"
        
        echo "✅ Lockfile updated and changes committed! Continuing with push..."
    fi
else
    echo "✅ Lockfile is in sync with package.json"
fi

# Check for changes outside development/ and public/ directories
echo "Checking for relevant file changes..."

# Get files changed between base commit and HEAD
CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
if [ $? -ne 0 ]; then
    echo "❌ Error getting changed files. This might happen if you're pushing a new branch."
    echo "Proceeding with tests to be safe..."
    RUN_TESTS=true
else
    # Flag to indicate if we need to run tests
    RUN_TESTS=false

    # Use a different approach to avoid subshell issues
    for file in $CHANGED_FILES; do
        # Skip empty lines
        [ -z "$file" ] && continue
        
        # Check if file is NOT in development/ or public/ directories
        if ! [[ "$file" =~ ^(development/|public/) ]]; then
            echo "🔍 Found change in $file - will run pipeline tests"
            RUN_TESTS=true
        fi
    done
fi

# Set RUN_TESTS to false if SKIP_TESTS is true
if [ "$SKIP_TESTS" = "true" ]; then
    RUN_TESTS=false
    echo "⏩ Test execution has been skipped due to SKIP_TESTS=true flag"
fi

if [ "$RUN_TESTS" = true ]; then
    # Check if .github directory has changes
    GITHUB_DIR_CHANGES=$(git diff --name-only HEAD^ HEAD 2>/dev/null | grep -c "^\.github/" || echo "0")
    
    # Only run workflow validation if .github directory has changes
    if [ "$GITHUB_DIR_CHANGES" -gt 0 ]; then
        echo "🔍 Changes detected in .github directory, validating workflows..."
        
        # Run the new validation script
        if [ -f "tests/pipeline-tests/validate-github-actions.sh" ]; then
            echo "Running GitHub Actions validator..."
            ./tests/pipeline-tests/validate-github-actions.sh || {
                echo "❌ GitHub Actions validation failed."
                echo "Please fix workflow syntax issues before pushing."
                exit 1
            }
        fi
        
        # Also run existing workflow alignment validator if available
        if [ -f ".github/scripts/pr/validate-workflow-alignment.sh" ]; then
            echo "Running workflow alignment validation..."
            ./.github/scripts/pr/validate-workflow-alignment.sh || {
                echo "❌ Workflow alignment validation failed."
                echo "Please fix workflow alignment issues before pushing."
                exit 1
            }
        else
            echo "⚠️ Workflow alignment script not found at .github/scripts/pr/validate-workflow-alignment.sh"
            echo "Skipping workflow alignment validation."
        fi
    else
        echo "✅ No changes in .github directory, skipping workflow validation."
    fi
    
    # Run unified pipeline with logging
    echo "🚀 Running unified pipeline test with full logging..."
    pnpm test
    TEST_STATUS=$?
    echo "Test command exited with status: $TEST_STATUS"
    
    if [ $TEST_STATUS -ne 0 ]; then
        echo "❌ Pipeline test failed. See output above for details."
        exit 1
    fi
    
    # Explicitly indicate tests passed
    echo "✅ Pipeline tests passed! Moving to build step..."

    # Run build to ensure it succeeds
    echo "🏗️ Running build..."
    pnpm build
    BUILD_STATUS=$?
    echo "Build command exited with status: $BUILD_STATUS"
    
    if [ $BUILD_STATUS -ne 0 ]; then
        echo "❌ Build failed. Please fix build issues before pushing."
        exit 1
    fi
    echo "✅ Build passed!"
    
    # Initialize version bump tracking variables
    PREVIOUS_VERSIONS=()
    NEW_VERSIONS=()
    VERSION_CHANGES=()
    
    # Check if there are any changeset files to consume
    CHANGESET_COUNT=$(find .changeset -name "*.md" -not -name "README.md" -not -name "config.json" | wc -l | tr -d ' ')
    
    if [ "$CHANGESET_COUNT" -gt 0 ]; then
        echo "📦 Found $CHANGESET_COUNT changesets to consume."
        
        # Collect original versions before bumping
        echo "📋 Collecting original package versions..."
        declare -A ORIGINAL_VERSIONS
        
        # Scan packages/ directory for original versions
        for PKG_DIR in packages/*; do
            if [ -d "$PKG_DIR" ] && [ -f "$PKG_DIR/package.json" ]; then
                PKG_NAME=$(grep -m 1 '"name":' "$PKG_DIR/package.json" | sed 's/.*"name": "\(.*\)".*/\1/')
                PKG_VERSION=$(grep -m 1 '"version":' "$PKG_DIR/package.json" | sed 's/.*"version": "\(.*\)".*/\1/')
                ORIGINAL_VERSIONS["$PKG_NAME"]="$PKG_VERSION"
            fi
        done
        
        # Scan apps/ directory for original versions
        for APP_DIR in apps/*; do
            if [ -d "$APP_DIR" ] && [ -f "$APP_DIR/package.json" ]; then
                APP_NAME=$(grep -m 1 '"name":' "$APP_DIR/package.json" | sed 's/.*"name": "\(.*\)".*/\1/')
                APP_VERSION=$(grep -m 1 '"version":' "$APP_DIR/package.json" | sed 's/.*"version": "\(.*\)".*/\1/')
                ORIGINAL_VERSIONS["$APP_NAME"]="$APP_VERSION"
            fi
        done
        
        # Create a temporary branch to work on in case we need to abort
        CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD)
        TEMP_BRANCH="temp-changeset-version-$(date +%s)"
        
        if [ "$DRY_RUN" = true ]; then
            echo "🔬 [DRY RUN] Would create temporary branch $TEMP_BRANCH to process changesets"
            
            # Simulate running changeset version
            echo "🔬 [DRY RUN] Would run 'pnpm changeset version' to bump package versions"
            
            # In dry run mode, we'll simulate version bumps based on the changesets
            # by parsing the changeset files to identify what packages would be affected
            
            echo "🔬 [DRY RUN] Simulating version changes based on changesets..."
            
            # Initialize arrays for simulated tracking
            SIMULATED_PACKAGE_NAMES=()
            SIMULATED_PACKAGE_VERSIONS=()
            SIMULATED_TAGS=()
            
            # Analyze changeset files to guess what would be bumped
            CHANGESET_FILES=$(find .changeset -name "*.md" -not -name "README.md" -not -name "config.json")
            
            for CHANGESET_FILE in $CHANGESET_FILES; do
                # Extract package names from changeset files (this is a simplified simulation)
                AFFECTED_PACKAGES=$(grep -A 10 "^---" "$CHANGESET_FILE" | grep -v "^---" | grep "^'" | sed "s/^'//g" | sed "s/'.*//g" || echo "")
                
                # Extract bump type from changeset content (major, minor, patch)
                BUMP_TYPE=$(grep -i -o -E "(major|minor|patch)" "$CHANGESET_FILE" | head -1 || echo "patch")
                
                for PKG in $AFFECTED_PACKAGES; do
                    if [ -n "$PKG" ] && [ -n "${ORIGINAL_VERSIONS[$PKG]}" ]; then
                        CURRENT_VERSION="${ORIGINAL_VERSIONS[$PKG]}"
                        
                        # Parse current version
                        MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
                        MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
                        PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
                        
                        # Simulate version bump based on bump type
                        case "$BUMP_TYPE" in
                            major)
                                MAJOR=$((MAJOR + 1))
                                MINOR=0
                                PATCH=0
                                ;;
                            minor)
                                MINOR=$((MINOR + 1))
                                PATCH=0
                                ;;
                            patch|*)
                                PATCH=$((PATCH + 1))
                                ;;
                        esac
                        
                        # Construct new version
                        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
                        
                        # Add to simulated tracking
                        SIMULATED_PACKAGE_NAMES+=("$PKG")
                        SIMULATED_PACKAGE_VERSIONS+=("$NEW_VERSION")
                        SIMULATED_TAGS+=("$PKG@$NEW_VERSION")
                        
                        # Track version changes for reporting
                        VERSION_CHANGES+=("$PKG: $CURRENT_VERSION → $NEW_VERSION")
                    fi
                done
            done
            
            echo "🔬 [DRY RUN] Would commit version changes"
            
            # Simulate creating tags
            echo "🔬 [DRY RUN] Would create the following tags:"
            CREATED_TAGS=()
            for i in "${!SIMULATED_PACKAGE_NAMES[@]}"; do
                TAG_NAME="${SIMULATED_PACKAGE_NAMES[$i]}@${SIMULATED_PACKAGE_VERSIONS[$i]}"
                echo "  - $TAG_NAME"
                CREATED_TAGS+=("$TAG_NAME")
            done
            
            echo "🔬 [DRY RUN] Would merge changes back to $CURRENT_BRANCH"
            echo "🔬 [DRY RUN] Would delete temporary branch $TEMP_BRANCH"
            
            # Get the remote name and branch being pushed to from the pre-push arguments
            read -r _ _ remote_ref _ < "/dev/stdin" || true
            
            if [ -n "$remote_ref" ]; then
                REMOTE=$(git remote | head -n 1)
                REMOTE_BRANCH=${remote_ref#refs/heads/}
                
                echo "🔬 [DRY RUN] Would push tags with branch for publishing"
            fi
        else
            # Actual execution (non-dry-run)
            echo "Creating temporary branch $TEMP_BRANCH to safely process changesets..."
            git checkout -b "$TEMP_BRANCH" || {
                echo "❌ Failed to create temporary branch. Aborting push."
                exit 1
            }
            
            # Run changeset version to consume changesets and bump versions
            echo "📈 Running changeset version to bump package versions..."
            pnpm changeset version
            VERSION_STATUS=$?
            
            if [ $VERSION_STATUS -ne 0 ]; then
                echo "❌ Changeset version failed with status $VERSION_STATUS. Reverting changes and aborting push."
                git checkout "$CURRENT_BRANCH"
                git branch -D "$TEMP_BRANCH"
                exit 1
            }
            
            # Collect updated package information for tags
            echo "📋 Collecting updated package information for tags..."
            # Store package paths and new versions in arrays
            PACKAGE_PATHS=()
            PACKAGE_NAMES=()
            PACKAGE_VERSIONS=()
            CREATED_TAGS=()
            
            # Collect packages from packages/ directory
            for PKG_DIR in packages/*; do
                if [ -d "$PKG_DIR" ] && [ -f "$PKG_DIR/package.json" ]; then
                    PKG_PATH="$PKG_DIR"
                    PKG_NAME=$(grep -m 1 '"name":' "$PKG_DIR/package.json" | sed 's/.*"name": "\(.*\)".*/\1/')
                    PKG_VERSION=$(grep -m 1 '"version":' "$PKG_DIR/package.json" | sed 's/.*"version": "\(.*\)".*/\1/')
                    
                    PACKAGE_PATHS+=("$PKG_PATH")
                    PACKAGE_NAMES+=("$PKG_NAME")
                    PACKAGE_VERSIONS+=("$PKG_VERSION")
                    
                    # Track version changes
                    if [[ -n "${ORIGINAL_VERSIONS[$PKG_NAME]}" && "${ORIGINAL_VERSIONS[$PKG_NAME]}" != "$PKG_VERSION" ]]; then
                        PREVIOUS_VERSIONS+=("${ORIGINAL_VERSIONS[$PKG_NAME]}")
                        NEW_VERSIONS+=("$PKG_VERSION")
                        VERSION_CHANGES+=("$PKG_NAME: ${ORIGINAL_VERSIONS[$PKG_NAME]} → $PKG_VERSION")
                    fi
                fi
            done
            
            # Collect packages from apps/ directory
            for APP_DIR in apps/*; do
                if [ -d "$APP_DIR" ] && [ -f "$APP_DIR/package.json" ]; then
                    APP_PATH="$APP_DIR"
                    APP_NAME=$(grep -m 1 '"name":' "$APP_DIR/package.json" | sed 's/.*"name": "\(.*\)".*/\1/')
                    APP_VERSION=$(grep -m 1 '"version":' "$APP_DIR/package.json" | sed 's/.*"version": "\(.*\)".*/\1/')
                    
                    PACKAGE_PATHS+=("$APP_PATH")
                    PACKAGE_NAMES+=("$APP_NAME")
                    PACKAGE_VERSIONS+=("$APP_VERSION")
                    
                    # Track version changes
                    if [[ -n "${ORIGINAL_VERSIONS[$APP_NAME]}" && "${ORIGINAL_VERSIONS[$APP_NAME]}" != "$APP_VERSION" ]]; then
                        PREVIOUS_VERSIONS+=("${ORIGINAL_VERSIONS[$APP_NAME]}")
                        NEW_VERSIONS+=("$APP_VERSION")
                        VERSION_CHANGES+=("$APP_NAME: ${ORIGINAL_VERSIONS[$APP_NAME]} → $APP_VERSION")
                    fi
                fi
            done
            
            # Commit the version changes
            echo "💾 Committing version changes..."
            git add .
            git commit -m "chore(pipeline): version packages"
            COMMIT_STATUS=$?
            
            if [ $COMMIT_STATUS -ne 0 ]; then
                echo "❌ Failed to commit version changes with status $COMMIT_STATUS. Reverting changes and aborting push."
                git checkout "$CURRENT_BRANCH"
                git branch -D "$TEMP_BRANCH"
                exit 1
            fi
            
            # Create tags for each updated package
            echo "🏷️ Creating tags for updated packages..."
            for i in "${!PACKAGE_NAMES[@]}"; do
                TAG_NAME="${PACKAGE_NAMES[$i]}@${PACKAGE_VERSIONS[$i]}"
                echo "Creating tag $TAG_NAME"
                git tag -a "$TAG_NAME" -m "Release ${PACKAGE_NAMES[$i]} version ${PACKAGE_VERSIONS[$i]}"
                CREATED_TAGS+=("$TAG_NAME")
            done
            
            # Everything looks good, merge back to the original branch
            echo "🔄 Merging changes back to $CURRENT_BRANCH..."
            git checkout "$CURRENT_BRANCH" || {
                echo "❌ Failed to checkout original branch. You may need to manually clean up temporary branch $TEMP_BRANCH."
                exit 1
            }
            
            git merge --no-ff "$TEMP_BRANCH" -m "chore(pipeline): merge version changes"
            MERGE_STATUS=$?
            
            # Clean up temp branch regardless of merge status
            git branch -D "$TEMP_BRANCH" || echo "⚠️ Warning: Could not delete temporary branch $TEMP_BRANCH"
            
            if [ $MERGE_STATUS -ne 0 ]; then
                echo "❌ Failed to merge version changes with status $MERGE_STATUS. Aborting push."
                echo "Please resolve any merge conflicts and try again."
                exit 1
            fi
            
            echo "✅ Successfully versioned packages, created tags, and committed changes!"
            
            # Get the remote name and branch being pushed to from the pre-push arguments
            # Format: local_ref local_sha remote_ref remote_sha
            read -r _ _ remote_ref _ < "/dev/stdin"
            
            if [ -n "$remote_ref" ]; then
                # Extract remote name and branch from remote ref (refs/heads/main -> origin main)
                REMOTE=$(git remote | head -n 1) # Default to first remote if we can't extract it
                REMOTE_BRANCH=${remote_ref#refs/heads/}
                
                # Allow normal push to continue as husky will do this automatically
                # Just need to ensure tags are pushed too
                echo "📤 Will push tags with branch for publishing"
                
                # Set this flag so the tags get pushed with the branch
                git config --local push.followTags true
                
                # Log the created tags for reference
                if [ ${#CREATED_TAGS[@]} -gt 0 ]; then
                    echo "🏷️ Created the following tags which will be pushed:"
                    for TAG in "${CREATED_TAGS[@]}"; do
                        echo "  - $TAG"
                    done
                fi
            else
                echo "⚠️ Could not determine remote details. Proceeding with normal push."
            fi
        fi
    else
        echo "ℹ️ No changesets found to consume. Skipping version bump."
    fi
    
    if [ "$DRY_RUN" = true ]; then
        echo "✅ All pre-push checks completed successfully in dry-run mode!"
    else
        echo "✅ All pre-push checks completed successfully!"
    fi
else
    echo "✅ No changes detected outside development/ and public/ directories. Skipping tests."
fi

# Disable debugging before exiting
# set +x

# Generate detailed version bump report
if [ ${#VERSION_CHANGES[@]} -gt 0 ]; then
    echo ""
    if [ "$DRY_RUN" = true ]; then
        echo "📊 VERSION BUMP REPORT (DRY RUN) 📊"
        echo "=================================="
        echo "The following packages WOULD BE bumped:"
    else
        echo "📊 VERSION BUMP REPORT 📊"
        echo "=================================="
        echo "The following packages were bumped:"
    fi
    
    for change in "${VERSION_CHANGES[@]}"; do
        echo "  ↑ $change"
    done
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        echo "🏷️ TAGS THAT WOULD BE CREATED 🏷️"
    else
        echo "🏷️ TAGS CREATED 🏷️"
    fi
    
    echo "=================================="
    for TAG in "${CREATED_TAGS[@]}"; do
        echo "  ➕ $TAG"
    done
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        echo "In an actual run, these changes would be pushed to the remote repository."
        echo "The tags would trigger release workflows for the updated packages."
    else
        echo "These changes will be pushed to the remote repository."
        echo "The tags will trigger release workflows for the updated packages."
    fi
    echo "=================================="
else
    if [ "$CHANGESET_COUNT" -gt 0 ]; then
        echo ""
        if [ "$DRY_RUN" = true ]; then
            echo "⚠️ Changesets were analyzed but no version changes were detected."
        else
            echo "⚠️ Changesets were processed but no version changes were detected."
        fi
        echo "This might indicate an issue with the changesets or the versioning process."
    fi
fi

if [ "$DRY_RUN" = true ]; then
    echo "🔬 DRY RUN COMPLETED - No actual changes were made"
    echo "Run without the --dry-run flag to apply these changes when pushing"
else
    echo "🎉 Pre-push checks completed successfully!"
fi

# Exit with success in dry run mode
if [ "$DRY_RUN" = true ]; then
    exit 0
fi

exit 0 