#!/bin/bash
# Running pre-push checks directly without husky sourcing

# Change to repository root directory to ensure commands work correctly
cd "$(git rev-parse --show-toplevel)" || exit 1

echo "üîç Running pre-push checks..."

# First, verify the lockfile is in sync with package.json
echo "Verifying lockfile integrity..."
# Check if lockfile is out of sync using pnpm's lockfile-report
pnpm install --frozen-lockfile --prefer-offline --lockfile-only > /dev/null 2>&1
LOCKFILE_STATUS=$?

if [ $LOCKFILE_STATUS -ne 0 ]; then
    echo "‚ö†Ô∏è Lockfile is out of sync with package.json."
    echo "üîß Automatically updating lockfile..."
    
    # Update lockfile
    pnpm install --no-frozen-lockfile
    
    # Commit the changes
    git add pnpm-lock.yaml
    git commit -m "chore: update lockfile to match package.json"
    
    echo "‚úÖ Lockfile updated and changes committed! Continuing with push..."
else
    echo "‚úÖ Lockfile is in sync with package.json"
fi

# Run versioning checks and updates
echo "üî¢ Checking package versions..."
CURRENT_BRANCH=$(git branch --show-current)

# Determine base reference for versioning: use most recent tag or first commit
echo "Finding base reference for version comparison..."

# Try to find most recent tag
LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

if [ -n "$LATEST_TAG" ]; then
  # Use the most recent tag as base reference
  FROM_REF="$LATEST_TAG"
  echo "Using most recent tag as base reference: ${FROM_REF}"
else
  # If no tags found, use the first commit in the repository
  FROM_REF=$(git rev-list --max-parents=0 HEAD)
  echo "No tags found. Using first commit as base reference: ${FROM_REF}"
fi

# Run in dry-run mode first to preview changes
echo "Performing version analysis (dry run)..."
node .github/scripts/versioning/version-from-commits.js --dry-run --from=${FROM_REF} --to=HEAD
VERSION_CHANGES=$?
echo "Version detection exit code: $VERSION_CHANGES (0=changes detected, 1=no changes)"

if [ $VERSION_CHANGES -eq 0 ]; then
    # If version changes detected, apply them
    echo "üì¶ Version changes needed. Updating package versions..."
    
    # Use the exact same reference for actual run
    echo "Applying version changes using: --from=${FROM_REF} --to=HEAD"
    node .github/scripts/versioning/version-from-commits.js --from=${FROM_REF} --to=HEAD --create-tags
    VERSION_UPDATE_STATUS=$?
    
    if [ $VERSION_UPDATE_STATUS -ne 0 ]; then
        echo "‚ùå Failed to update package versions (exit code: $VERSION_UPDATE_STATUS). Push will continue, but versions may be out of sync."
    else
        echo "‚úÖ Package versions updated successfully based on commit history."
        
        # Commit the version changes
        if [ -n "$(git status --porcelain)" ]; then
            echo "üì¶ Committing version changes..."
            git add .
            git commit -m "chore(release): update package versions based on commit history"
            echo "‚úÖ Version changes committed! Continuing with push..."
        fi
    fi
else
    echo "‚úÖ No version changes needed (exit code: $VERSION_CHANGES)."
fi

# Don't exit on error for the remainder of the script to allow debug logging
set +e

# Check for changes outside development/ and public/ directories
echo "Checking for relevant file changes..."

# Use the same base reference for file comparison
BASE_COMMIT=${FROM_REF}
echo "Comparing files with base: ${BASE_COMMIT}"

# Get files changed between base commit and HEAD
CHANGED_FILES=$(git diff --name-only $BASE_COMMIT HEAD)

# Flag to indicate if we need to run tests
RUN_TESTS=false

# Use a different approach to avoid subshell issues
for file in $CHANGED_FILES; do
    # Skip empty lines
    [ -z "$file" ] && continue
    
    # Check if file is NOT in development/ or public/ directories
    if ! [[ "$file" =~ ^(development/|public/) ]]; then
        echo "üîç Found change in $file - will run pipeline tests"
        RUN_TESTS=true
    fi
done

if [ "$RUN_TESTS" = true ]; then
    # Check if .github directory has changes
    GITHUB_DIR_CHANGES=$(git diff --name-only $BASE_COMMIT HEAD | grep -c "^\.github/")
    
    # Only run workflow validation if .github directory has changes
    if [ "$GITHUB_DIR_CHANGES" -gt 0 ]; then
        echo "üîç Changes detected in .github directory, validating workflows..."
        
        # Run the new validation script
        if [ -f "tests/pipeline-tests/validate-github-actions.sh" ]; then
            echo "Running GitHub Actions validator..."
            ./tests/pipeline-tests/validate-github-actions.sh || {
                echo "‚ùå GitHub Actions validation failed."
                echo "Please fix workflow syntax issues before pushing."
                exit 1
            }
        fi
        
        # Also run existing workflow alignment validator if available
        if [ -f ".github/scripts/pr/validate-workflow-alignment.sh" ]; then
            echo "Running workflow alignment validation..."
            ./.github/scripts/pr/validate-workflow-alignment.sh || {
                echo "‚ùå Workflow alignment validation failed."
                echo "Please fix workflow alignment issues before pushing."
                exit 1
            }
        else
            echo "‚ö†Ô∏è Workflow alignment script not found at .github/scripts/pr/validate-workflow-alignment.sh"
            echo "Skipping workflow alignment validation."
        fi
    else
        echo "‚úÖ No changes in .github directory, skipping workflow validation."
    fi
    
    # Run unified pipeline with logging
    echo "üöÄ Running unified pipeline test with full logging..."
    pnpm test
    TEST_STATUS=$?
    echo "Test command exited with status: $TEST_STATUS"
    
    if [ $TEST_STATUS -ne 0 ]; then
        echo "‚ùå Pipeline test failed. See output above for details."
        exit 1
    fi
    
    # Explicitly indicate tests passed
    echo "‚úÖ Pipeline tests passed! Moving to build step..."

    # Run build to ensure it succeeds
    echo "üèóÔ∏è Running build..."
    pnpm build
    BUILD_STATUS=$?
    echo "Build command exited with status: $BUILD_STATUS"
    
    if [ $BUILD_STATUS -ne 0 ]; then
        echo "‚ùå Build failed. Please fix build issues before pushing."
        exit 1
    fi
    echo "‚úÖ Build passed!"
    
    echo "‚úÖ All pre-push checks completed successfully!"
else
    echo "‚úÖ No changes detected outside development/ and public/ directories. Skipping tests."
fi

echo "üéâ Pre-push script reached the end! Exiting with success."
# Force success to allow the push to proceed
exit 0 