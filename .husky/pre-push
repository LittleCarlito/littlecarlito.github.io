#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# Exit on error
set -e

echo "üîç Running pre-push checks..."

# First, verify the lockfile is in sync with package.json
echo "Verifying lockfile integrity..."
pnpm verify-lockfile || {
    echo "‚ö†Ô∏è Lockfile is out of sync with package.json."
    echo "üîß Automatically updating lockfile..."
    
    # Update lockfile
    pnpm update-lockfile
    
    # Commit the changes
    git add pnpm-lock.yaml
    git commit -m "chore: update lockfile to match package.json"
    
    echo "‚úÖ Lockfile updated and changes committed! Continuing with push..."
}

# Get the current branch name
BRANCH=$(git symbolic-ref --short HEAD)

# Check for changes outside development/ and public/ directories
echo "Checking for relevant file changes..."

# Get the base commit for comparison - use safer detection
CURRENT_BRANCH=$(git branch --show-current)
BASE_COMMIT=""

# Check if the branch exists on the remote
if git ls-remote --heads origin $CURRENT_BRANCH | grep -q $CURRENT_BRANCH; then
    # Branch exists on remote, use it as base
    BASE_COMMIT="origin/$CURRENT_BRANCH"
    echo "Comparing with existing remote branch: $BASE_COMMIT"
else
    # Branch doesn't exist on remote yet, use the branch point from main
    BASE_COMMIT=$(git merge-base origin/main HEAD)
    echo "New branch, comparing with merge-base from main: $BASE_COMMIT"
fi

# Get files changed between base commit and HEAD
CHANGED_FILES=$(git diff --name-only $BASE_COMMIT HEAD)

# Flag to indicate if we need to run tests
RUN_TESTS=false

# Use a different approach to avoid subshell issues
for file in $CHANGED_FILES; do
    # Skip empty lines
    [ -z "$file" ] && continue
    
    # Check if file is NOT in development/ or public/ directories
    if ! [[ "$file" =~ ^(development/|public/) ]]; then
        echo "üîç Found change in $file - will run pipeline tests"
        RUN_TESTS=true
    fi
done

if [ "$RUN_TESTS" = true ]; then
    # Check if .github directory has changes
    GITHUB_DIR_CHANGES=$(git diff --name-only $BASE_COMMIT HEAD | grep -c "^\.github/")
    
    # Only run workflow validation if .github directory has changes
    if [ "$GITHUB_DIR_CHANGES" -gt 0 ]; then
        echo "üîç Changes detected in .github directory, validating workflow alignment..."
        if [ -f ".github/scripts/pr/validate-workflow-alignment.sh" ]; then
            ./.github/scripts/pr/validate-workflow-alignment.sh || {
                echo "‚ùå Workflow alignment validation failed."
                echo "Please fix workflow alignment issues before pushing."
                exit 1
            }
        else
            echo "‚ö†Ô∏è Workflow validation script not found at .github/scripts/pr/validate-workflow-alignment.sh"
            echo "Skipping workflow validation."
        fi
    else
        echo "‚úÖ No changes in .github directory, skipping workflow validation."
    fi
    
    # Run unified pipeline with logging
    echo "üöÄ Running unified pipeline test with full logging..."
    pnpm test || {
        echo "‚ùå Pipeline test failed. See output above for details."
        exit 1
    }
    
    # Explicitly indicate tests passed
    echo "‚úÖ Pipeline tests passed! Moving to build step..."

    # Run build to ensure it succeeds
    echo "üèóÔ∏è Running build..."
    pnpm build || {
        echo "‚ùå Build failed. Please fix build issues before pushing."
        exit 1
    }
    echo "‚úÖ Build passed!"

    # TEMPORARY: Skip semantic-release checks for debugging
    echo "‚è≠Ô∏è TEMPORARILY SKIPPING semantic-release checks to debug pre-push issues"
    
    echo "‚úÖ All pre-push checks completed successfully!"
    exit 0
else
    echo "‚úÖ No changes detected outside development/ and public/ directories. Skipping tests."
fi

echo "‚úÖ All pre-push checks passed!" 
exit 0 