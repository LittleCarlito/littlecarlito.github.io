#!/usr/bin/env bash
# Running pre-push checks directly without husky sourcing

# Shell environment debug info
echo "Shell: $SHELL"
echo "Bash version: $BASH_VERSION"

# Set -e is removed to prevent silent exits
# Instead we'll explicitly handle errors and provide better logging

# Add debugging
# set -x

# Parse command-line arguments
DRY_RUN=false
PUSH_TAGS=true

# Check for command-line arguments
for arg in "$@"; do
  if [ "$arg" = "--dry-run" ]; then
    DRY_RUN=true
    echo "ðŸ”¬ DRY RUN MODE ENABLED - No changes will be committed or pushed"
  fi
  if [ "$arg" = "--no-tags" ]; then
    PUSH_TAGS=false
    echo "ðŸ·ï¸ TAGS WILL NOT BE PUSHED"
  fi
done

# Check if we should skip tests
SKIP_TESTS=${SKIP_TESTS:-false}
if [ "$SKIP_TESTS" = "true" ]; then
  echo "â© SKIPPING TESTS"
fi

# Change to repository root directory to ensure commands work correctly
cd "$(git rev-parse --show-toplevel)" || {
    echo "âŒ Failed to change to repository root directory"
    exit 1
}

echo "ðŸ” Running pre-push checks..."

# First, verify the lockfile is in sync with package.json
echo "Verifying lockfile integrity..."
# Check if lockfile is out of sync using pnpm's lockfile-report
pnpm install --frozen-lockfile --prefer-offline --lockfile-only > /dev/null 2>&1
LOCKFILE_STATUS=$?

if [ $LOCKFILE_STATUS -ne 0 ]; then
    echo "âš ï¸ Lockfile is out of sync with package.json."
    if [ "$DRY_RUN" = true ]; then
        echo "ðŸ”¬ [DRY RUN] Would update lockfile and commit changes"
    else
        echo "ðŸ”§ Automatically updating lockfile..."
        
        # Update lockfile
        pnpm install --no-frozen-lockfile
        
        # Commit the changes
        git add pnpm-lock.yaml
        git commit -m "chore: update lockfile to match package.json"
        
        echo "âœ… Lockfile updated and changes committed! Continuing with push..."
    fi
else
    echo "âœ… Lockfile is in sync with package.json"
fi

# Check if there are uncommitted package version changes
echo "Checking for uncommitted package version changes..."
UNCOMMITTED_VERSIONS=$(git diff --name-only --diff-filter=M -- "**/package.json" | wc -l)
if [ "$UNCOMMITTED_VERSIONS" -gt 0 ]; then
    echo "âš ï¸ Found uncommitted package version changes in package.json file(s)"
    git diff --name-only --diff-filter=M -- "**/package.json"
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        echo "ðŸ”¬ [DRY RUN] Would run automatic versioning"
    else
        # Check for existing remote tags before creating new ones
        echo "ðŸ” Checking for existing remote tags..."
        git fetch --tags
        
        # Get a list of packages with version changes
        CHANGED_PACKAGES=$(git diff --name-only --diff-filter=M -- "**/package.json" | xargs dirname)
        WILL_CREATE_TAGS=false
        
        for pkg_dir in $CHANGED_PACKAGES; do
            PKG_NAME=$(node -e "console.log(require('./$pkg_dir/package.json').name)")
            PKG_VERSION=$(node -e "console.log(require('./$pkg_dir/package.json').version)")
            POTENTIAL_TAG="$PKG_NAME@$PKG_VERSION"
            
            # Check if this tag already exists remotely
            if git ls-remote --tags origin "refs/tags/$POTENTIAL_TAG" | grep -q "$POTENTIAL_TAG"; then
                echo "âš ï¸ Tag $POTENTIAL_TAG already exists on the remote repository. Skipping version creation."
            else
                echo "âœ… No existing tag found for $POTENTIAL_TAG. Will proceed with version creation."
                WILL_CREATE_TAGS=true
            fi
        done
        
        if [ "$WILL_CREATE_TAGS" = "true" ]; then
            echo "ðŸ·ï¸ Running full versioning with tag creation..."
            # Run lerna version with tag creation for all branches
            # Use the ignore-scripts flag to avoid running the version script from package.json
            pnpm version:local-tags
            
            # Re-stage any changes made by lerna
            git add .
            git commit -m "chore(release): publish [skip ci]" || echo "No changes to commit"
            
            echo "âœ… Versioning completed! Tags created before push."
            
            # Set flag to push with tags
            PUSH_WITH_TAGS=true
        else
            echo "â© Skipping versioning since all necessary tags already exist."
        fi
    fi
fi

# Check if we should push tags with this branch
CURRENT_BRANCH=$(git symbolic-ref --short HEAD)
if [ "$PUSH_TAGS" = true ]; then
    # First check if there are any local tags that point to HEAD
    LOCAL_HEAD_TAGS=$(git tag -l --points-at HEAD | wc -l | tr -d '[:space:]')
    
    if [ "$LOCAL_HEAD_TAGS" -gt 0 ]; then
        echo "ðŸ·ï¸ Found $LOCAL_HEAD_TAGS local tag(s) for the current commit"
        git tag -l --points-at HEAD
        PUSH_WITH_TAGS=true
    else
        echo "âœ… No new tags pointing to current HEAD"
        
        # If no HEAD tags, check for any local tags that don't exist on remote
        echo "ðŸ” Checking for historical local tags not on remote..."
        # Fetch all remote tags for comparison
        git fetch --tags origin
        
        # Get count of local tags that don't exist on remote
        git tag | sort > /tmp/local_tags
        git ls-remote --tags origin | grep -v '\^{}' | awk '{print $2}' | sed 's|refs/tags/||' | sort > /tmp/remote_tags
        LOCAL_ONLY_HISTORICAL_TAGS=$(comm -23 /tmp/local_tags /tmp/remote_tags | wc -l | tr -d '[:space:]')
        
        if [ "$LOCAL_ONLY_HISTORICAL_TAGS" -gt 0 ]; then
            echo "ðŸ·ï¸ Found $LOCAL_ONLY_HISTORICAL_TAGS local tag(s) not on remote"
            # List the tags for visibility
            comm -23 /tmp/local_tags /tmp/remote_tags
            PUSH_WITH_TAGS=true
        else
            echo "âœ… No local tags ahead of remote"
        fi
    fi
else
    echo "â© Tag pushing is disabled, only pushing branch"
fi

# Check for changes outside development/ and public/ directories
echo "Checking for relevant file changes..."

# Get files changed between base commit and HEAD
CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
if [ $? -ne 0 ]; then
    echo "âŒ Error getting changed files. This might happen if you're pushing a new branch."
    echo "Proceeding with tests to be safe..."
    RUN_TESTS=true
else
    # Flag to indicate if we need to run tests
    RUN_TESTS=false

    # Use a different approach to avoid subshell issues
    for file in $CHANGED_FILES; do
        # Skip empty lines
        [ -z "$file" ] && continue
        
        # Check if file is NOT in development/ or public/ directories
        if ! [[ "$file" =~ ^(development/|public/) ]]; then
            echo "ðŸ” Found change in $file - will run pipeline tests"
            RUN_TESTS=true
        fi
    done
fi

# Set RUN_TESTS to false if SKIP_TESTS is true
if [ "$SKIP_TESTS" = "true" ]; then
    RUN_TESTS=false
    echo "â© Test execution has been skipped due to SKIP_TESTS=true flag"
fi

if [ "$RUN_TESTS" = true ]; then
    # Check if .github directory has changes
    GITHUB_DIR_CHANGES=$(git diff --name-only HEAD^ HEAD 2>/dev/null | grep -c "^\.github/" || echo "0")
    
    # Only run workflow validation if .github directory has changes
    if [ "$GITHUB_DIR_CHANGES" -gt 0 ]; then
        echo "ðŸ” Changes detected in .github directory, validating workflows..."
        
        # Run the new validation script
        if [ -f "tests/pipeline-tests/validate-github-actions.sh" ]; then
            echo "Running GitHub Actions validator..."
            ./tests/pipeline-tests/validate-github-actions.sh || {
                echo "âŒ GitHub Actions validation failed."
                echo "Please fix workflow syntax issues before pushing."
                exit 1
            }
        fi
        
        # Also run existing workflow alignment validator if available
        if [ -f ".github/scripts/pr/validate-workflow-alignment.sh" ]; then
            echo "Running workflow alignment validation..."
            ./.github/scripts/pr/validate-workflow-alignment.sh || {
                echo "âŒ Workflow alignment validation failed."
                echo "Please fix workflow alignment issues before pushing."
                exit 1
            }
        else
            echo "âš ï¸ Workflow alignment script not found at .github/scripts/pr/validate-workflow-alignment.sh"
            echo "Skipping workflow alignment validation."
        fi
    else
        echo "âœ… No changes in .github directory, skipping workflow validation."
    fi
    
    # Run unified pipeline with logging
    echo "ðŸš€ Running unified pipeline test with full logging..."
    pnpm test
    TEST_STATUS=$?
    echo "Test command exited with status: $TEST_STATUS"
    
    if [ $TEST_STATUS -ne 0 ]; then
        echo "âŒ Pipeline test failed. See output above for details."
        exit 1
    fi
    
    # Explicitly indicate tests passed
    echo "âœ… Pipeline tests passed! Moving to build step..."

    # Run build to ensure it succeeds
    echo "ðŸ—ï¸ Running build..."
    pnpm build
    BUILD_STATUS=$?
    echo "Build command exited with status: $BUILD_STATUS"
    
    if [ $BUILD_STATUS -ne 0 ]; then
        echo "âŒ Build failed. Please fix build issues before pushing."
        exit 1
    fi
    echo "âœ… Build passed!"
fi

if [ "$DRY_RUN" = true ]; then
    echo "ðŸ”¬ DRY RUN COMPLETED - No actual changes were made"
    echo "Run without the --dry-run flag to apply these changes when pushing"
else
    # If we need to push with tags, we'll do it here
    if [ "$PUSH_WITH_TAGS" = true ]; then
        echo "ðŸš€ Pushing branch with tags..."
        # This command executes a push with the --follow-tags flag
        # Note: This needs to be changed if you want to push to a specific remote and branch
        git tag | sort > /tmp/local_tags
        git ls-remote --tags origin | grep -v '\^{}' | awk '{print $2}' | sed 's|refs/tags/||' | sort > /tmp/remote_tags
        comm -23 /tmp/local_tags /tmp/remote_tags
        rm /tmp/local_tags /tmp/remote_tags
        exec git push --follow-tags "${@:2}"
        # Exit code will be the status of the git push command
    else
        echo "ðŸŽ‰ Pre-push checks completed successfully!"
    fi
fi

# Exit with success in dry run mode
if [ "$DRY_RUN" = true ]; then
    exit 0
fi

exit 0 