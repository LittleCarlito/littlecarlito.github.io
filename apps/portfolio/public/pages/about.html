<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: transparent !important;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        .scale-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-origin: center center;
        }

        .page {
            width: 100%;
            height: 100%;
            background: white !important;
            border-right: 2px solid #ccc;
            box-shadow: 5px 0 15px rgba(0, 0, 0, 0.1);
            display: grid;
            grid-template-rows: auto 1fr;
        }

        .header-section {
            position: relative;
            width: 100%;
        }

        h1 {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: calc(2vw + 1.5em);
            margin: 0;
            left: 60%;
            transform: translate(-50%, -50%);
            padding-top: 3em;
        }

        .profile-picture {
            position: absolute;
            top: 30px;
            left: 10px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #ccc;
            pointer-events: none;
            user-select: none;
        }

        .content-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2em;
            box-sizing: border-box;
        }

        .about-text {
            position: absolute;
            width: 70vw;
            text-align: left;
            left: 60%;
            transform: translateX(-50%);
            top: 80px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            font-size: calc(1vw + 0.6em);
        }

        .physics-container {
            margin-top: 30vh;
            width: 90vw;
            height: 60vh;
            border: 2px solid #ccc;
            border-radius: 8px;
            overflow: hidden;
            background: transparent;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        .water-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        canvas {
            cursor: grab;
        }

        @media screen and (max-width: 600px) {
            h1 { font-size: 1.8em; }
            .about-text { font-size: 1em; }
        }

        @media screen and (min-width: 1200px) {
            h1 { font-size: 2.8em; }
            .about-text { font-size: 1.2em; }
        }
    </style>
</head>
<body>
    <div class="scale-container">
        <div class="page">
            <div class="header-section">
                <img src="../images/pxArt.png" alt="Profile Picture" class="profile-picture">
                <h1>ABOUT</h1>
            </div>
            <p class="about-text">I have been in the software development industry since 2014. Holding positions from Change Management Representative to Java Engineer at multiple Fortune 500 and 100 companies. Programming is pretty much all I do, reach out to me and maybe I can do it for you!</p>
            <div class="content-wrapper">
                <div id="physics-container" class="physics-container">
                    <div id="water-container" class="water-container"></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">       
        function scaleContent() {
            const container = document.querySelector('.scale-container');
            const content = document.querySelector('.page');
            const contentRect = content.getBoundingClientRect();
            const scale = Math.min(window.innerWidth / contentRect.width, window.innerHeight / contentRect.height, 1);
            container.style.transform = `scale(${scale})`;
        }
        window.addEventListener('load', scaleContent);
        window.addEventListener('resize', scaleContent);
    </script>

    <script src="https://unpkg.com/matter-js@0.19.0/build/matter.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script>
        const skills = [
            { name: 'React', icon: '../logos/react.svg' },
            { name: 'ThreeJS', icon: '../logos/threejs.svg' },
            { name: 'JavaScript', icon: '../logos/js.svg' },
            { name: 'TypeScript', icon: '../logos/ts.svg' },
            { name: 'HTML', icon: '../logos/html.svg' },
            { name: 'CSS', icon: '../logos/css.svg' },
            { name: 'WebGL', icon: '../logos/web_gl.svg' },
            { name: 'Spring Boot', icon: '../logos/spring.svg' },
            { name: 'Java', icon: '../logos/java.svg' },
            { name: 'SQL', icon: '../logos/sql.svg' },
            { name: 'Kubernetes', icon: '../logos/kubernetes.svg' },
            { name: 'Docker', icon: '../logos/docker.svg' },
            { name: 'AWS', icon: '../logos/aws.svg' },
            { name: 'GDScript', icon: '../logos/gdscript.svg' },
            { name: 'JUnit 5', icon: '../logos/junit.svg' }
        ];

        let engine, render, world, walls, runner;
        let physicsObjects = [];
        let waterEffect = { initialized: false };

        function initPhysics() {
            const container = document.getElementById('physics-container');
            engine = Matter.Engine.create();
            world = engine.world;
            engine.world.gravity.y = 0;

            render = Matter.Render.create({
                element: container,
                engine: engine,
                options: {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    wireframes: false,
                    background: 'transparent'
                }
            });

            const radius = 30;
            skills.forEach((skill) => {
                const x = Math.random() * (container.clientWidth - radius * 2) + radius;
                const y = Math.random() * (container.clientHeight - radius * 2) + radius;
                
                const logo = Matter.Bodies.circle(x, y, radius, {
                    render: {
                        sprite: {
                            texture: skill.icon,
                            xScale: 1,
                            yScale: 1
                        }
                    },
                    restitution: 0.6,
                    friction: 0.001,
                    density: 0.0005,
                    frictionAir: 0.03
                });

                Matter.World.add(world, logo);
                physicsObjects.push(logo);
            });

            const mouse = Matter.Mouse.create(render.canvas);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: { stiffness: 0.2, render: { visible: false } }
            });
            Matter.World.add(world, mouseConstraint);

            // Simplified physics behavior
            let frameCounter = 0;
            Matter.Events.on(engine, 'beforeUpdate', () => {
                frameCounter++;
                if (frameCounter % 3 !== 0) return; // Reduced calculation frequency

                physicsObjects.forEach(logo => {
                    const velocity = logo.velocity;
                    const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
                    
                    if (speed < 0.5) {
                        const direction = Math.random() > 0.5 ? 1 : -1;
                        Matter.Body.setVelocity(logo, {
                            x: direction * 2,
                            y: (Math.random() - 0.5) * 0.5
                        });
                    }
                    
                    // Simple avoidance
                    if (mouseConstraint.mouse.position) {
                        const dx = mouseConstraint.mouse.position.x - logo.position.x;
                        const dy = mouseConstraint.mouse.position.y - logo.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < radius * 4) {
                            const force = 0.002;
                            Matter.Body.applyForce(logo, logo.position, {
                                x: -(dx / distance) * force,
                                y: -(dy / distance) * force
                            });
                        }
                    }
                });
            });

            walls = [
                Matter.Bodies.rectangle(container.clientWidth/2, -10, container.clientWidth, 20, { isStatic: true }),
                Matter.Bodies.rectangle(container.clientWidth/2, container.clientHeight + 10, container.clientWidth, 20, { isStatic: true }),
                Matter.Bodies.rectangle(-10, container.clientHeight/2, 20, container.clientHeight, { isStatic: true }),
                Matter.Bodies.rectangle(container.clientWidth + 10, container.clientHeight/2, 20, container.clientHeight, { isStatic: true })
            ];
            Matter.World.add(world, walls);

            runner = Matter.Runner.create({ delta: 1000/30 }); // Reduced to 30 FPS
            Matter.Runner.run(runner, engine);
            Matter.Render.run(render);
        }

        function initWaterEffect() {
            const container = document.getElementById('water-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 0.1, 1000);
            camera.position.z = 1;
            
            // Render targets for ping-pong
            const bufferA = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            const bufferB = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            const bufferB1 = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            const bufferB2 = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            let currentBufferA = bufferA;
            let previousBufferA = bufferB;
            let currentBufferB = bufferB1;
            let previousBufferB = bufferB2;
            
            let mousePosition = new THREE.Vector2(-1000, -1000);
            let mousePressed = false;
            
            // Buffer A shader (water physics)
            const bufferAMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iFrame: { value: 0 },
                    iMouse: { value: new THREE.Vector4(-1000, -1000, 0, 0) },
                    iResolution: { value: new THREE.Vector2(width, height) },
                    iChannel0: { value: null },
                    iChannel1: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float iTime;
                    uniform int iFrame;
                    uniform vec4 iMouse;
                    uniform vec2 iResolution;
                    uniform sampler2D iChannel0;
                    uniform sampler2D iChannel1;
                    varying vec2 vUv;
                    
                    vec2 uvToPixel(vec2 uv) { return uv * iResolution; }
                    vec4 texelFetch(sampler2D tex, ivec2 pixel, int lod) {
                        return texture2D(tex, (vec2(pixel) + 0.5) / iResolution);
                    }
                    
                    #define T(a,b) texelFetch(iChannel0, ivec2(coord)+ivec2(a,b), 0)
                    #define B(U) texelFetch(iChannel1, ivec2(U), 0)
                    
                    void main() {
                        vec2 coord = uvToPixel(vUv);
                        
                        float h = (T(0, 1).x + T(0, -1).x + T(1, 0).x + T(-1, 0).x) / 2.0;
                        float t = 0.99 * (h - T(0, 0).y);
                        
                        if (iMouse.x > -999.0) {
                            if (iMouse.z > 0.5 && 18.0 - length(iMouse.xy - coord) > 0.0) {
                                t = 1.4;
                            } 
                            else if (25.0 - length(iMouse.xy - coord) > 0.0) {
                                float mouseRippleIntensity = 0.25 + 0.2 * sin(iTime * 10.0);
                                t += mouseRippleIntensity * (1.0 - length(iMouse.xy - coord) / 25.0);
                            }
                        }
                        
                        vec4 bData = B(coord);
                        
                        if (iFrame < 10) {
                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        } else {
                            float damping = max(4.0 - length(bData.xy - coord), 0.0) * length(bData.zw + vec2(0.001)) / 200.0;
                            gl_FragColor = vec4(t - damping, T(0, 0).x, 0.0, 1.0);
                        }
                    }
                `
            });
            
            // Buffer B shader (particle physics)
            const bufferBMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iFrame: { value: 0 },
                    iMouse: { value: new THREE.Vector4(0, 0, 0, 0) },
                    iResolution: { value: new THREE.Vector2(width, height) },
                    iChannel0: { value: null },
                    iChannel1: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float iTime;
                    uniform int iFrame;
                    uniform vec4 iMouse;
                    uniform vec2 iResolution;
                    uniform sampler2D iChannel0;
                    uniform sampler2D iChannel1;
                    varying vec2 vUv;
                    
                    vec2 uvToPixel(vec2 uv) { return uv * iResolution; }
                    vec4 texelFetch(sampler2D tex, ivec2 pixel, int lod) {
                        return texture2D(tex, (vec2(pixel) + 0.5) / iResolution);
                    }
                    
                    #define Pspawn 20.0
                    #define Pgrid 5.0
                    #define A(U) texelFetch(iChannel0, ivec2(U), 0).x
                    #define B(a,b) texelFetch(iChannel1, ivec2(coord) + ivec2(a,b), 0)
                    #define dA(U,R) A(U+R)-A(U-R)
                    #define N(U,A,B) if(length(U-B.xy)<length(U-A.xy)){A = B;}
                    
                    void main() {
                        vec2 coord = uvToPixel(vUv);
                        
                        vec4 particle = B(0, 0);
                        N(coord, particle, B(0, 1));
                        N(coord, particle, B(1, 0));
                        N(coord, particle, B(0, -1));
                        N(coord, particle, B(-1, 0));
                        N(coord, particle, B(2, 2));
                        N(coord, particle, B(2, -2));
                        N(coord, particle, B(-2, 2));
                        N(coord, particle, B(-2, -2));
                        
                        if (iFrame == 0 || (length(coord - particle.xy) > Pspawn)) {
                            particle = vec4(round(coord / Pgrid) * Pgrid, 0.0, 0.0);
                        }
                        
                        particle.zw -= vec2(dA(particle.xy, vec2(1.0, 0.0)), dA(particle.xy, vec2(0.0, 1.0)));
                        particle.zw *= 0.99;
                        particle.xy += particle.zw;
                        
                        gl_FragColor = particle;
                    }
                `
            });
            
            // Render shader (final output)
            const renderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iResolution: { value: new THREE.Vector2(width, height) },
                    iChannel0: { value: null },
                    iChannel1: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float iTime;
                    uniform vec2 iResolution;
                    uniform sampler2D iChannel0;
                    uniform sampler2D iChannel1;
                    varying vec2 vUv;
                    
                    vec2 uvToPixel(vec2 uv) { return uv * iResolution; }
                    vec4 texelFetch(sampler2D tex, ivec2 pixel, int lod) {
                        return texture2D(tex, (vec2(pixel) + 0.5) / iResolution);
                    }
                    
                    #define l normalize(vec2(1))
                    #define A(U) texelFetch(iChannel0, ivec2(U), 0).x
                    #define B(U) texelFetch(iChannel1, ivec2(U), 0).xy
                    #define dA(U,R) A(U+R)-A(U-R)
                    #define DB(U) length(B(U)-U)
                    #define dDB(U,R) DB(U+R)-DB(U-R)
                    
                    float shimmer(vec2 coord, float time) {
                        float waves = sin(coord.x * 0.05 + time) * sin(coord.y * 0.04 + time * 0.8) * 0.5 + 0.5;
                        return waves * 0.07;
                    }
                    
                    void main() {
                        vec2 coord = uvToPixel(vUv);
                        
                        vec3 waterColor = vec3(0.12, 0.2, 0.7) + 
                            0.5 * dot(vec2(dA(coord, vec2(1.0, 0.0)), dA(coord, vec2(0.0, 1.0))), l);
                        
                        float particleEffect = 0.0;
                        vec2 gradientDB = vec2(dDB(coord, vec2(1.0, 0.0)), dDB(coord, vec2(0.0, 1.0)));
                        
                        if (length(gradientDB) > 0.0) {
                            particleEffect = (0.5 * dot(normalize(gradientDB), l) + 0.5) 
                                           * max(1.0 - 0.5 * length(coord - B(coord)), 0.0);
                        }
                        
                        vec3 finalColor = waterColor;
                        finalColor.b += 0.08;
                        finalColor.r *= 0.9;
                        
                        float shimmerEffect = shimmer(coord, iTime);
                        finalColor.b += shimmerEffect * 0.4;
                        finalColor.g += shimmerEffect * 0.15;
                        
                        float distFromCenter = length(coord - iResolution * 0.5) / length(iResolution * 0.5);
                        float edgeFade = smoothstep(0.7, 1.0, distFromCenter);
                        
                        vec3 edgeColor = vec3(0.25, 0.4, 0.8);
                        finalColor = mix(finalColor, edgeColor, edgeFade * 0.2);
                        
                        float rippleIntensity = abs(dA(coord, vec2(1.0, 0.0))) + abs(dA(coord, vec2(0.0, 1.0)));
                        rippleIntensity *= 0.7;
                        
                        float baseAlpha = 0.12 * (1.0 - edgeFade * 0.3);
                        float alphaBoost = min(0.4, rippleIntensity * 1.8);
                        float alpha = mix(baseAlpha, min(0.25, baseAlpha + 0.15), alphaBoost);
                        
                        finalColor = mix(finalColor, finalColor * 1.1, min(0.4, rippleIntensity * 0.8));
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true
            });
            
            const geometry = new THREE.PlaneGeometry(width, height);
            const renderMesh = new THREE.Mesh(geometry, renderMaterial);
            scene.add(renderMesh);
            
            // Mouse events
            const physicsContainer = document.getElementById('physics-container');
            
            physicsContainer.addEventListener('mouseenter', (event) => {
                const rect = container.getBoundingClientRect();
                mousePosition.x = event.clientX - rect.left;
                mousePosition.y = height - (event.clientY - rect.top);
                
                bufferAMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferAMaterial.uniforms.iMouse.value.y = mousePosition.y;
                bufferBMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferBMaterial.uniforms.iMouse.value.y = mousePosition.y;
            });
            
            physicsContainer.addEventListener('mouseleave', () => {
                bufferAMaterial.uniforms.iMouse.value.x = -1000;
                bufferAMaterial.uniforms.iMouse.value.y = -1000;
                bufferBMaterial.uniforms.iMouse.value.x = -1000;
                bufferBMaterial.uniforms.iMouse.value.y = -1000;
            });
            
            physicsContainer.addEventListener('mousemove', (event) => {
                const rect = container.getBoundingClientRect();
                mousePosition.x = event.clientX - rect.left;
                mousePosition.y = height - (event.clientY - rect.top);
                bufferAMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferAMaterial.uniforms.iMouse.value.y = mousePosition.y;
                bufferBMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferBMaterial.uniforms.iMouse.value.y = mousePosition.y;
                
                if (!mousePressed) {
                    bufferAMaterial.uniforms.iMouse.value.w = 1.0;
                }
            });
            
            physicsContainer.addEventListener('mousedown', (event) => {
                mousePressed = true;
                
                const rect = container.getBoundingClientRect();
                mousePosition.x = event.clientX - rect.left;
                mousePosition.y = height - (event.clientY - rect.top);
                
                bufferAMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferAMaterial.uniforms.iMouse.value.y = mousePosition.y;
                bufferAMaterial.uniforms.iMouse.value.z = 1.0;
                
                bufferBMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferBMaterial.uniforms.iMouse.value.y = mousePosition.y;
                bufferBMaterial.uniforms.iMouse.value.z = 1.0;
                
                bufferAMaterial.uniforms.iMouse.value.w = 0.0;
            });
            
            window.addEventListener('mouseup', () => {
                mousePressed = false;
                bufferAMaterial.uniforms.iMouse.value.z = 0.0;
                bufferBMaterial.uniforms.iMouse.value.z = 0.0;
            });
            
            // Animation loop with performance optimization
            let frameCount = 0;
            let lastTime = 0;
            const animate = (time) => {
                requestAnimationFrame(animate);
                
                // Cap to 45 FPS for better performance while keeping smoothness
                if (time - lastTime < 22) return;
                lastTime = time;
                
                const timeValue = time * 0.001;
                bufferAMaterial.uniforms.iTime.value = timeValue;
                bufferAMaterial.uniforms.iFrame.value = frameCount;
                bufferBMaterial.uniforms.iTime.value = timeValue;
                bufferBMaterial.uniforms.iFrame.value = frameCount;
                renderMaterial.uniforms.iTime.value = timeValue;
                
                // Update Buffer B
                renderer.setRenderTarget(currentBufferB);
                bufferBMaterial.uniforms.iChannel0.value = previousBufferA.texture;
                bufferBMaterial.uniforms.iChannel1.value = previousBufferB.texture;
                scene.overrideMaterial = bufferBMaterial;
                renderer.render(scene, camera);
                
                // Swap B buffers
                let temp = previousBufferB;
                previousBufferB = currentBufferB;
                currentBufferB = temp;
                
                // Update Buffer A
                renderer.setRenderTarget(currentBufferA);
                bufferAMaterial.uniforms.iChannel0.value = previousBufferA.texture;
                bufferAMaterial.uniforms.iChannel1.value = previousBufferB.texture;
                scene.overrideMaterial = bufferAMaterial;
                renderer.render(scene, camera);
                
                // Swap A buffers
                temp = previousBufferA;
                previousBufferA = currentBufferA;
                currentBufferA = temp;
                
                // Render to screen
                renderer.setRenderTarget(null);
                renderMaterial.uniforms.iChannel0.value = previousBufferA.texture;
                renderMaterial.uniforms.iChannel1.value = previousBufferB.texture;
                scene.overrideMaterial = renderMaterial;
                renderer.render(scene, camera);
                
                frameCount++;
            };
            
            waterEffect = { 
                renderer, 
                bufferA, bufferB, bufferB1, bufferB2,
                bufferAMaterial, bufferBMaterial, renderMaterial,
                initialized: true 
            };
            
            animate(0);
        }

        // Optimized resize handler
        function handleResize() {
            setTimeout(() => {
                const container = document.getElementById('physics-container');
                const waterContainer = document.getElementById('water-container');
                if (!container || !waterContainer) return;
                
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                
                if (render) {
                    render.options.width = newWidth;
                    render.options.height = newHeight;
                    render.canvas.width = newWidth;
                    render.canvas.height = newHeight;
                    
                    // Update walls
                    if (walls && walls.length) {
                        Matter.Composite.remove(world, walls);
                    }
                    walls = [
                        Matter.Bodies.rectangle(newWidth/2, -10, newWidth, 20, { isStatic: true }),
                        Matter.Bodies.rectangle(newWidth/2, newHeight + 10, newWidth, 20, { isStatic: true }),
                        Matter.Bodies.rectangle(-10, newHeight/2, 20, newHeight, { isStatic: true }),
                        Matter.Bodies.rectangle(newWidth + 10, newHeight/2, 20, newHeight, { isStatic: true })
                    ];
                    Matter.World.add(world, walls);
                }
                
                if (waterEffect.initialized) {
                    // Simple resize for water effect
                    waterEffect.renderer.setSize(newWidth, newHeight);
                    waterEffect.bufferAMaterial.uniforms.iResolution.value.set(newWidth, newHeight);
                    waterEffect.bufferBMaterial.uniforms.iResolution.value.set(newWidth, newHeight);
                    waterEffect.renderMaterial.uniforms.iResolution.value.set(newWidth, newHeight);
                    
                    // Dispose old render targets
                    waterEffect.bufferA.dispose();
                    waterEffect.bufferB.dispose();
                    waterEffect.bufferB1.dispose();
                    waterEffect.bufferB2.dispose();
                    
                    // Create new render targets
                    const rtOptions = {
                        minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBAFormat,
                        type: THREE.FloatType
                    };
                    
                    waterEffect.bufferA = new THREE.WebGLRenderTarget(newWidth, newHeight, rtOptions);
                    waterEffect.bufferB = new THREE.WebGLRenderTarget(newWidth, newHeight, rtOptions);
                    waterEffect.bufferB1 = new THREE.WebGLRenderTarget(newWidth, newHeight, rtOptions);
                    waterEffect.bufferB2 = new THREE.WebGLRenderTarget(newWidth, newHeight, rtOptions);
                }
            }, 250);
        }
        
        window.addEventListener('load', () => {
            initPhysics();
            setTimeout(initWaterEffect, 200);
            window.addEventListener('resize', handleResize);
        });
    </script>
</body>
</html>