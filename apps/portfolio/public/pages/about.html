<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: transparent !important;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        .scale-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-origin: center center;
        }
        .page {
            width: 100%;
            height: 100%;
            background: white !important;
            border-right: 1px solid #ccc;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.1);
            display: grid;
            grid-template-rows: auto auto 1fr;
        }
        .header-section {
            position: relative;
            width: 100%;
            height: 35px;
        }
        h1 {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 18px;
            margin: 0;
            left: 50%;
            transform: translateX(-50%);
            top: 8px;
            font-weight: bold;
            letter-spacing: -0.5px;
        }
        .profile-text-section {
            width: 100%;
            display: flex;
            align-items: center;
            padding: 5px 20px;
            box-sizing: border-box;
            gap: 20px;
        }
        .profile-picture {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #ccc;
            pointer-events: none;
            user-select: none;
            flex-shrink: 0;
        }
        .about-text {
            flex: 1;
            max-width: 400px;
            text-align: left;
            word-wrap: break-word;
            overflow-wrap: break-word;
            font-size: 13px;
            line-height: 1.4;
            letter-spacing: -0.2px;
            font-weight: 400;
            margin: 0;
        }
        .content-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
        }
        .physics-container {
            width: 98%;
            height: calc(100% - 20px);
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
            background: transparent;
            box-shadow: 0 1px 5px rgba(0,0,0,0.1);
            position: relative;
            min-height: 120px;
        }
        .water-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        canvas {
            cursor: grab;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <div class="scale-container">
        <div class="page">
            <div class="header-section">
                <h1>ABOUT</h1>
            </div>
            <div class="profile-text-section">
                <img src="../images/pxArt.png" alt="Profile Picture" class="profile-picture">
                <p class="about-text">I have been in the software development industry since 2014. Holding positions from Change Management Representative to Java Engineer at multiple Fortune 500 and 100 companies. Programming is pretty much all I do, reach out to me and maybe I can do it for you!</p>
            </div>
            <div class="content-wrapper">
                <div id="physics-container" class="physics-container">
                    <div id="water-container" class="water-container"></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">       
        function scaleContent() {
            const container = document.querySelector('.scale-container');
            const content = document.querySelector('.page');
            const contentRect = content.getBoundingClientRect();
            const scale = Math.min(window.innerWidth / contentRect.width, window.innerHeight / contentRect.height, 1);
            container.style.transform = `scale(${scale})`;
        }
        window.addEventListener('load', scaleContent);
        window.addEventListener('resize', scaleContent);
    </script>

    <script src="https://unpkg.com/matter-js@0.19.0/build/matter.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script>
        const skills = [
            { name: 'React', icon: '../logos/react.svg' },
            { name: 'ThreeJS', icon: '../logos/threejs.svg' },
            { name: 'JavaScript', icon: '../logos/js.svg' },
            { name: 'TypeScript', icon: '../logos/ts.svg' },
            { name: 'HTML', icon: '../logos/html.svg' },
            { name: 'CSS', icon: '../logos/css.svg' },
            { name: 'WebGL', icon: '../logos/web_gl.svg' },
            { name: 'Spring Boot', icon: '../logos/spring.svg' },
            { name: 'Java', icon: '../logos/java.svg' },
            { name: 'SQL', icon: '../logos/sql.svg' },
            { name: 'Kubernetes', icon: '../logos/kubernetes.svg' },
            { name: 'Docker', icon: '../logos/docker.svg' },
            { name: 'AWS', icon: '../logos/aws.svg' },
            { name: 'GDScript', icon: '../logos/gdscript.svg' },
            { name: 'JUnit 5', icon: '../logos/junit.svg' }
        ];

        let engine, render, world, walls, runner;
        let physicsObjects = [];
        let waterEffect = { initialized: false };

        function initPhysics() {
            const container = document.getElementById('physics-container');
            engine = Matter.Engine.create();
            world = engine.world;
            engine.world.gravity.y = 0;

            render = Matter.Render.create({
                element: container,
                engine: engine,
                options: {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    wireframes: false,
                    background: 'transparent',
                    pixelRatio: 1
                }
            });

            const radius = 18;
            skills.forEach((skill) => {
                const x = Math.random() * (container.clientWidth - radius * 2) + radius;
                const y = Math.random() * (container.clientHeight - radius * 2) + radius;
                
                const logo = Matter.Bodies.circle(x, y, radius, {
                    render: {
                        sprite: {
                            texture: skill.icon,
                            xScale: 1,
                            yScale: 1
                        }
                    },
                    restitution: 0.6,
                    friction: 0.001,
                    density: 0.0005,
                    frictionAir: 0.03
                });

                Matter.World.add(world, logo);
                physicsObjects.push(logo);
            });

            const mouse = Matter.Mouse.create(render.canvas);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: { stiffness: 0.2, render: { visible: false } }
            });
            Matter.World.add(world, mouseConstraint);

            let frameCounter = 0;
            Matter.Events.on(engine, 'beforeUpdate', () => {
                frameCounter++;
                if (frameCounter % 3 !== 0) return;

                physicsObjects.forEach(logo => {
                    const velocity = logo.velocity;
                    const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
                    
                    if (speed < 0.5) {
                        const direction = Math.random() > 0.5 ? 1 : -1;
                        Matter.Body.setVelocity(logo, {
                            x: direction * 1,
                            y: (Math.random() - 0.5) * 0.3
                        });
                    }
                    
                    if (mouseConstraint.mouse.position) {
                        const dx = mouseConstraint.mouse.position.x - logo.position.x;
                        const dy = mouseConstraint.mouse.position.y - logo.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < radius * 4) {
                            const force = 0.0015;
                            Matter.Body.applyForce(logo, logo.position, {
                                x: -(dx / distance) * force,
                                y: -(dy / distance) * force
                            });
                        }
                    }
                });
            });

            walls = [
                Matter.Bodies.rectangle(container.clientWidth/2, -10, container.clientWidth, 20, { isStatic: true }),
                Matter.Bodies.rectangle(container.clientWidth/2, container.clientHeight + 10, container.clientWidth, 20, { isStatic: true }),
                Matter.Bodies.rectangle(-10, container.clientHeight/2, 20, container.clientHeight, { isStatic: true }),
                Matter.Bodies.rectangle(container.clientWidth + 10, container.clientHeight/2, 20, container.clientHeight, { isStatic: true })
            ];
            Matter.World.add(world, walls);

            runner = Matter.Runner.create({ delta: 1000/30 });
            Matter.Runner.run(runner, engine);
            Matter.Render.run(render);
        }

        function initWaterEffect() {
            const container = document.getElementById('water-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(1);
            container.appendChild(renderer.domElement);
            
            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 0.1, 1000);
            camera.position.z = 1;
            
            const bufferA = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            const bufferB = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            const bufferB1 = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            const bufferB2 = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            let currentBufferA = bufferA;
            let previousBufferA = bufferB;
            let currentBufferB = bufferB1;
            let previousBufferB = bufferB2;
            
            let mousePosition = new THREE.Vector2(-1000, -1000);
            let mousePressed = false;
            
            const bufferAMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iFrame: { value: 0 },
                    iMouse: { value: new THREE.Vector4(-1000, -1000, 0, 0) },
                    iResolution: { value: new THREE.Vector2(width, height) },
                    iChannel0: { value: null },
                    iChannel1: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float iTime;
                    uniform int iFrame;
                    uniform vec4 iMouse;
                    uniform vec2 iResolution;
                    uniform sampler2D iChannel0;
                    uniform sampler2D iChannel1;
                    varying vec2 vUv;
                    
                    vec2 uvToPixel(vec2 uv) { return uv * iResolution; }
                    vec4 texelFetch(sampler2D tex, ivec2 pixel, int lod) {
                        return texture2D(tex, (vec2(pixel) + 0.5) / iResolution);
                    }
                    
                    #define T(a,b) texelFetch(iChannel0, ivec2(coord)+ivec2(a,b), 0)
                    #define B(U) texelFetch(iChannel1, ivec2(U), 0)
                    
                    void main() {
                        vec2 coord = uvToPixel(vUv);
                        
                        float h = (T(0, 1).x + T(0, -1).x + T(1, 0).x + T(-1, 0).x) / 2.0;
                        float t = 0.99 * (h - T(0, 0).y);
                        
                        if (iMouse.x > -999.0) {
                            if (iMouse.z > 0.5 && 18.0 - length(iMouse.xy - coord) > 0.0) {
                                t = 1.2;
                            } 
                            else if (25.0 - length(iMouse.xy - coord) > 0.0) {
                                float mouseRippleIntensity = 0.25 + 0.18 * sin(iTime * 8.0);
                                t += mouseRippleIntensity * (1.0 - length(iMouse.xy - coord) / 25.0);
                            }
                        }
                        
                        vec4 bData = B(coord);
                        
                        if (iFrame < 10) {
                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        } else {
                            float damping = max(3.0 - length(bData.xy - coord), 0.0) * length(bData.zw + vec2(0.001)) / 150.0;
                            gl_FragColor = vec4(t - damping, T(0, 0).x, 0.0, 1.0);
                        }
                    }
                `
            });
            
            const bufferBMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iFrame: { value: 0 },
                    iMouse: { value: new THREE.Vector4(0, 0, 0, 0) },
                    iResolution: { value: new THREE.Vector2(width, height) },
                    iChannel0: { value: null },
                    iChannel1: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float iTime;
                    uniform int iFrame;
                    uniform vec4 iMouse;
                    uniform vec2 iResolution;
                    uniform sampler2D iChannel0;
                    uniform sampler2D iChannel1;
                    varying vec2 vUv;
                    
                    vec2 uvToPixel(vec2 uv) { return uv * iResolution; }
                    vec4 texelFetch(sampler2D tex, ivec2 pixel, int lod) {
                        return texture2D(tex, (vec2(pixel) + 0.5) / iResolution);
                    }
                    
                    #define Pspawn 18.0
                    #define Pgrid 5.0
                    #define A(U) texelFetch(iChannel0, ivec2(U), 0).x
                    #define B(a,b) texelFetch(iChannel1, ivec2(coord) + ivec2(a,b), 0)
                    #define dA(U,R) A(U+R)-A(U-R)
                    #define N(U,A,B) if(length(U-B.xy)<length(U-A.xy)){A = B;}
                    
                    void main() {
                        vec2 coord = uvToPixel(vUv);
                        
                        vec4 particle = B(0, 0);
                        N(coord, particle, B(0, 1));
                        N(coord, particle, B(1, 0));
                        N(coord, particle, B(0, -1));
                        N(coord, particle, B(-1, 0));
                        N(coord, particle, B(2, 2));
                        N(coord, particle, B(2, -2));
                        N(coord, particle, B(-2, 2));
                        N(coord, particle, B(-2, -2));
                        
                        if (iFrame == 0 || (length(coord - particle.xy) > Pspawn)) {
                            particle = vec4(round(coord / Pgrid) * Pgrid, 0.0, 0.0);
                        }
                        
                        particle.zw -= vec2(dA(particle.xy, vec2(1.0, 0.0)), dA(particle.xy, vec2(0.0, 1.0)));
                        particle.zw *= 0.99;
                        particle.xy += particle.zw;
                        
                        gl_FragColor = particle;
                    }
                `
            });
            
            const renderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iResolution: { value: new THREE.Vector2(width, height) },
                    iChannel0: { value: null },
                    iChannel1: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float iTime;
                    uniform vec2 iResolution;
                    uniform sampler2D iChannel0;
                    uniform sampler2D iChannel1;
                    varying vec2 vUv;
                    
                    vec2 uvToPixel(vec2 uv) { return uv * iResolution; }
                    vec4 texelFetch(sampler2D tex, ivec2 pixel, int lod) {
                        return texture2D(tex, (vec2(pixel) + 0.5) / iResolution);
                    }
                    
                    #define l normalize(vec2(1))
                    #define A(U) texelFetch(iChannel0, ivec2(U), 0).x
                    #define B(U) texelFetch(iChannel1, ivec2(U), 0).xy
                    #define dA(U,R) A(U+R)-A(U-R)
                    #define DB(U) length(B(U)-U)
                    #define dDB(U,R) DB(U+R)-DB(U-R)
                    
                    float shimmer(vec2 coord, float time) {
                        float waves = sin(coord.x * 0.08 + time) * sin(coord.y * 0.06 + time * 0.8) * 0.5 + 0.5;
                        return waves * 0.05;
                    }
                    
                    void main() {
                        vec2 coord = uvToPixel(vUv);
                        
                        vec3 waterColor = vec3(0.12, 0.2, 0.7) + 
                            0.5 * dot(vec2(dA(coord, vec2(1.0, 0.0)), dA(coord, vec2(0.0, 1.0))), l);
                        
                        float particleEffect = 0.0;
                        vec2 gradientDB = vec2(dDB(coord, vec2(1.0, 0.0)), dDB(coord, vec2(0.0, 1.0)));
                        
                        if (length(gradientDB) > 0.0) {
                            particleEffect = (0.5 * dot(normalize(gradientDB), l) + 0.5) 
                                           * max(1.0 - 0.5 * length(coord - B(coord)), 0.0);
                        }
                        
                        vec3 finalColor = waterColor;
                        finalColor.b += 0.08;
                        finalColor.r *= 0.9;
                        
                        float shimmerEffect = shimmer(coord, iTime);
                        finalColor.b += shimmerEffect * 0.4;
                        finalColor.g += shimmerEffect * 0.15;
                        
                        float distFromCenter = length(coord - iResolution * 0.5) / length(iResolution * 0.5);
                        float edgeFade = smoothstep(0.7, 1.0, distFromCenter);
                        
                        vec3 edgeColor = vec3(0.25, 0.4, 0.8);
                        finalColor = mix(finalColor, edgeColor, edgeFade * 0.2);
                        
                        float rippleIntensity = abs(dA(coord, vec2(1.0, 0.0))) + abs(dA(coord, vec2(0.0, 1.0)));
                        rippleIntensity *= 0.7;
                        
                        float baseAlpha = 0.10 * (1.0 - edgeFade * 0.3);
                        float alphaBoost = min(0.35, rippleIntensity * 1.5);
                        float alpha = mix(baseAlpha, min(0.22, baseAlpha + 0.12), alphaBoost);
                        
                        finalColor = mix(finalColor, finalColor * 1.1, min(0.4, rippleIntensity * 0.8));
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true
            });
            
            const geometry = new THREE.PlaneGeometry(width, height);
            const renderMesh = new THREE.Mesh(geometry, renderMaterial);
            scene.add(renderMesh);
            
            const physicsContainer = document.getElementById('physics-container');
            
            physicsContainer.addEventListener('mouseenter', (event) => {
                const rect = container.getBoundingClientRect();
                mousePosition.x = event.clientX - rect.left;
                mousePosition.y = height - (event.clientY - rect.top);
                
                bufferAMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferAMaterial.uniforms.iMouse.value.y = mousePosition.y;
                bufferBMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferBMaterial.uniforms.iMouse.value.y = mousePosition.y;
            });
            
            physicsContainer.addEventListener('mouseleave', () => {
                bufferAMaterial.uniforms.iMouse.value.x = -1000;
                bufferAMaterial.uniforms.iMouse.value.y = -1000;
                bufferBMaterial.uniforms.iMouse.value.x = -1000;
                bufferBMaterial.uniforms.iMouse.value.y = -1000;
            });
            
            physicsContainer.addEventListener('mousemove', (event) => {
                const rect = container.getBoundingClientRect();
                mousePosition.x = event.clientX - rect.left;
                mousePosition.y = height - (event.clientY - rect.top);
                bufferAMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferAMaterial.uniforms.iMouse.value.y = mousePosition.y;
                bufferBMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferBMaterial.uniforms.iMouse.value.y = mousePosition.y;
                
                if (!mousePressed) {
                    bufferAMaterial.uniforms.iMouse.value.w = 1.0;
                }
            });
            
            physicsContainer.addEventListener('mousedown', (event) => {
                mousePressed = true;
                
                const rect = container.getBoundingClientRect();
                mousePosition.x = event.clientX - rect.left;
                mousePosition.y = height - (event.clientY - rect.top);
                
                bufferAMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferAMaterial.uniforms.iMouse.value.y = mousePosition.y;
                bufferAMaterial.uniforms.iMouse.value.z = 1.0;
                
                bufferBMaterial.uniforms.iMouse.value.x = mousePosition.x;
                bufferBMaterial.uniforms.iMouse.value.y = mousePosition.y;
                bufferBMaterial.uniforms.iMouse.value.z = 1.0;
                
                bufferAMaterial.uniforms.iMouse.value.w = 0.0;
            });
            
            window.addEventListener('mouseup', () => {
                mousePressed = false;
                bufferAMaterial.uniforms.iMouse.value.z = 0.0;
                bufferBMaterial.uniforms.iMouse.value.z = 0.0;
            });
            
            let frameCount = 0;
            let lastTime = 0;
            const animate = (time) => {
                requestAnimationFrame(animate);
                
                if (time - lastTime < 33) return;
                lastTime = time;
                
                const timeValue = time * 0.001;
                bufferAMaterial.uniforms.iTime.value = timeValue;
                bufferAMaterial.uniforms.iFrame.value = frameCount;
                bufferBMaterial.uniforms.iTime.value = timeValue;
                bufferBMaterial.uniforms.iFrame.value = frameCount;
                renderMaterial.uniforms.iTime.value = timeValue;
                
                renderer.setRenderTarget(currentBufferB);
                bufferBMaterial.uniforms.iChannel0.value = previousBufferA.texture;
                bufferBMaterial.uniforms.iChannel1.value = previousBufferB.texture;
                scene.overrideMaterial = bufferBMaterial;
                renderer.render(scene, camera);
                
                let temp = previousBufferB;
                previousBufferB = currentBufferB;
                currentBufferB = temp;
                
                renderer.setRenderTarget(currentBufferA);
                bufferAMaterial.uniforms.iChannel0.value = previousBufferA.texture;
                bufferAMaterial.uniforms.iChannel1.value = previousBufferB.texture;
                scene.overrideMaterial = bufferAMaterial;
                renderer.render(scene, camera);
                
                temp = previousBufferA;
                previousBufferA = currentBufferA;
                currentBufferA = temp;
                
                renderer.setRenderTarget(null);
                renderMaterial.uniforms.iChannel0.value = previousBufferA.texture;
                renderMaterial.uniforms.iChannel1.value = previousBufferB.texture;
                scene.overrideMaterial = renderMaterial;
                renderer.render(scene, camera);
                
                frameCount++;
            };
            
            waterEffect = { 
                renderer, 
                bufferA, bufferB, bufferB1, bufferB2,
                bufferAMaterial, bufferBMaterial, renderMaterial,
                initialized: true 
            };
            
            animate(0);
        }

        function handleResize() {
            setTimeout(() => {
                const container = document.getElementById('physics-container');
                const waterContainer = document.getElementById('water-container');
                if (!container || !waterContainer) return;
                
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                
                if (render) {
                    render.options.width = newWidth;
                    render.options.height = newHeight;
                    render.canvas.width = newWidth;
                    render.canvas.height = newHeight;
                    
                    if (walls && walls.length) {
                        Matter.Composite.remove(world, walls);
                    }
                    walls = [
                        Matter.Bodies.rectangle(newWidth/2, -10, newWidth, 20, { isStatic: true }),
                        Matter.Bodies.rectangle(newWidth/2, newHeight + 10, newWidth, 20, { isStatic: true }),
                        Matter.Bodies.rectangle(-10, newHeight/2, 20, newHeight, { isStatic: true }),
                        Matter.Bodies.rectangle(newWidth + 10, newHeight/2, 20, newHeight, { isStatic: true })
                    ];
                    Matter.World.add(world, walls);
                }
                
                if (waterEffect.initialized) {
                    waterEffect.renderer.setSize(newWidth, newHeight);
                    waterEffect.bufferAMaterial.uniforms.iResolution.value.set(newWidth, newHeight);
                    waterEffect.bufferBMaterial.uniforms.iResolution.value.set(newWidth, newHeight);
                    waterEffect.renderMaterial.uniforms.iResolution.value.set(newWidth, newHeight);
                    
                    waterEffect.bufferA.dispose();
                    waterEffect.bufferB.dispose();
                    waterEffect.bufferB1.dispose();
                    waterEffect.bufferB2.dispose();
                    
                    const rtOptions = {
                        minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBAFormat,
                        type: THREE.FloatType
                    };
                    
                    waterEffect.bufferA = new THREE.WebGLRenderTarget(newWidth, newHeight, rtOptions);
                    waterEffect.bufferB = new THREE.WebGLRenderTarget(newWidth, newHeight, rtOptions);
                    waterEffect.bufferB1 = new THREE.WebGLRenderTarget(newWidth, newHeight, rtOptions);
                    waterEffect.bufferB2 = new THREE.WebGLRenderTarget(newWidth, newHeight, rtOptions);
                }
            }, 250);
        }
        
        window.addEventListener('load', () => {
            initPhysics();
            setTimeout(initWaterEffect, 200);
            window.addEventListener('resize', handleResize);
        });
    </script>
</body>
</html>