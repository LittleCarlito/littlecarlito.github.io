name: Main Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      triggered_by:
        description: 'Workflow that triggered this run'
        required: false
        default: 'manual'

# Improve concurrency handling to avoid cancelling important runs
concurrency:
  group: main-pipeline-${{ github.sha }}
  cancel-in-progress: false

# Define reusable variables
env:
  BUILD_ARTIFACT_NAME: build-artifacts-${{ github.run_id }}
  PACKAGES_ARTIFACT_NAME: package-builds-${{ github.run_id }}
  
# Note: This workflow handles GitHub Pages deployment directly.
# The separate deploy-pages.yml workflow should be disabled or deleted.
permissions:
  contents: write
  packages: write
  pull-requests: write
  statuses: write
  id-token: write
  actions: write
  issues: write

jobs:
  # Capture information about what triggered this workflow
  capture-trigger-info:
    name: Capture Trigger Info
    runs-on: ubuntu-latest
    outputs:
      trigger_actor: ${{ steps.set-trigger-info.outputs.trigger_actor }}
      triggering_workflow: ${{ steps.set-trigger-info.outputs.triggering_workflow }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Set trigger information
        id: set-trigger-info
        run: |
          # Determine what triggered this workflow
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ github.event.inputs.triggered_by }}" != "" ]; then
            # Triggered by another workflow
            echo "trigger_workflow=${{ github.event.inputs.triggered_by }}" >> "$GITHUB_OUTPUT"
            echo "triggering_workflow=${{ github.event.inputs.triggered_by }}" >> "$GITHUB_OUTPUT"
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger
            echo "trigger_workflow=manual" >> "$GITHUB_OUTPUT"
            echo "triggering_workflow=manual" >> "$GITHUB_OUTPUT"
          else
            # Direct push to main
            echo "trigger_workflow=direct_push" >> "$GITHUB_OUTPUT"
            echo "triggering_workflow=direct" >> "$GITHUB_OUTPUT"
          fi
          
          # Set actor info
          echo "trigger_actor=${{ github.actor }}" >> "$GITHUB_OUTPUT"
          
          # Print debug info
          echo "Workflow triggered by: ${{ github.event_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Ref: ${{ github.ref }}"
          echo "SHA: ${{ github.sha }}"

  build:
    name: Build
    needs: capture-trigger-info
    runs-on: ubuntu-latest
    outputs:
      build_artifact_name: ${{ env.BUILD_ARTIFACT_NAME }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
          
      - name: Debug environment
        run: |
          echo "Debugging environment before build..."
          echo "Node version: $(node -v)"
          echo "NPM version: $(npm -v)"
          command -v pnpm && echo "pnpm version: $(pnpm -v)" || echo "pnpm not found"
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          echo "Checking for package.json:"
          grep -E 'name|scripts|build' package.json
          echo "Installing dependencies explicitly:"
          npm install -g pnpm
          pnpm install
          echo "Environment debug complete"
          
      # Update .npmrc files to not require NODE_AUTH_TOKEN
      - name: Update .npmrc files
        run: |
          chmod +x .github/scripts/maintenance/update-npmrc.js
          node .github/scripts/maintenance/update-npmrc.js
          
      - name: Build packages
        uses: ./.github/actions/build-and-test
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          build-command: 'pnpm run build'
          test-command: 'echo "Tests will run in separate job"'
          artifact-name: ${{ env.BUILD_ARTIFACT_NAME }}
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BUILD_ARTIFACT_NAME }}
          path: packages
          if-no-files-found: error
          
      - name: Validate build artifacts
        run: |
          echo "Validating build artifacts..."
          # Check for dist directories
          DIST_DIRS=$(find packages -name "dist" -type d | wc -l)
          if [ "${DIST_DIRS}" -eq 0 ]; then
            echo "::error::No dist directories found in packages!"
            exit 1
          fi
          echo "Found ${DIST_DIRS} dist directories"
          
          # List all dist directories to verify they exist and contain files
          find packages -name "dist" -type d -exec ls -la {} \;
          
          # Count files to ensure we have artifacts
          FILE_COUNT=$(find packages -name "dist" -type d -exec find {} -type f \; | wc -l)
          echo "Found ${FILE_COUNT} files in artifact directories"
          
          if [ "${FILE_COUNT}" -eq 0 ]; then
            echo "::error::No build artifacts found in packages/dist directories!"
            exit 1
          fi
          
          echo "✅ Artifact validation successful - ${FILE_COUNT} files in ${DIST_DIRS} directories"

  test:
    name: Test
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
          
      # Download build artifacts explicitly first
      - name: Download build artifacts
        id: download-artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.build_artifact_name }}
          path: packages
        env:
          GH_TOKEN: ${{ secrets.PACKAGE_TOKEN }}
          
      # Validate that artifacts were successfully downloaded
      - name: Validate downloaded artifacts
        run: |
          echo "Validating downloaded artifacts..."
          # Check that artifacts were downloaded
          DIST_DIRS=$(find packages -name "dist" -type d | wc -l)
          if [ "${DIST_DIRS}" -eq 0 ]; then
            echo "::error::No dist directories found in downloaded artifacts!"
            exit 1
          fi
          
          # Count files to ensure we have artifacts
          FILE_COUNT=$(find packages -name "dist" -type d -exec find {} -type f \; | wc -l)
          echo "Found ${FILE_COUNT} files in ${DIST_DIRS} artifact directories"
          
          if [ "${FILE_COUNT}" -eq 0 ]; then
            echo "::error::Downloaded artifacts contain no files!"
            exit 1
          fi
          
          echo "✅ Downloaded artifacts validation successful"
          
      # Replace workflow call with direct use of the action
      - name: Test packages
        uses: ./.github/actions/test-packages
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          artifact-name: ${{ needs.build.outputs.build_artifact_name }}

  # Create GitHub Release if needed
  create-release:
    name: Create GitHub Release
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    outputs:
      created_releases: ${{ steps.check_and_create.outputs.created_releases }}
      tags_created: ${{ steps.check_and_create.outputs.tags_created }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          
      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: '8.15.4'
          
      - name: Install dependencies
        run: pnpm install
      
      # First, run custom versioning logic to ensure we have the correct versions
      - name: Run custom version determination
        id: custom_versions
        run: |
          echo "Running custom version determination..."
          
          # Make our scripts executable
          chmod +x .github/scripts/versioning/version-from-commits.js
          chmod +x .github/scripts/versioning/apply-custom-versions.js
          chmod +x .github/scripts/ci/debug-version-numbers.sh
          
          # Run diagnostics BEFORE version changes
          echo "=== VERSION DIAGNOSTICS BEFORE CHANGES ==="
          bash ".github/scripts/ci/debug-version-numbers.sh"
          
          # Get the first commit of the repository for comprehensive version generation
          FIRST_COMMIT="$(git rev-list --max-parents=0 HEAD)"
          echo "Using first commit as starting reference: ${FIRST_COMMIT}"
          
          # Generate changesets based on our custom logic
          node .github/scripts/versioning/version-from-commits.js --to=main --from="${FIRST_COMMIT}"
          
          # Apply our custom versions
          node .github/scripts/versioning/apply-custom-versions.js --branch=main
          
          # Run diagnostics AFTER version changes
          echo "=== VERSION DIAGNOSTICS AFTER CHANGES ==="
          bash ".github/scripts/ci/debug-version-numbers.sh"
          
          echo "Custom versioning completed"
          
      - name: Create releases for packages
        id: check_and_create
        run: |
          # Set git identity for creating tags
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Always process releases on merge to main
          echo "Processing releases for packages"
          
          # Find all package.json files in apps and packages - now with our custom versions
          PACKAGE_JSONS="$(find apps packages -name "package.json" -not -path "*/node_modules/*")"
          
          # Variables to track results
          CREATED_RELEASES="false"
          TAGS_CREATED=""
          
          # Process each package
          for PKG_JSON in ${PACKAGE_JSONS}; do
            # Get package info
            PKG_NAME="$(node -p "require('./${PKG_JSON}').name")"
            PKG_VERSION="$(node -p "require('./${PKG_JSON}').version")"
            PKG_DIR="$(dirname "${PKG_JSON}")"
            
            # Skip packages without proper version or name
            if [[ -z "${PKG_VERSION}" || "${PKG_VERSION}" == "0.0.0" || -z "${PKG_NAME}" ]]; then
              echo "Skipping ${PKG_JSON} - invalid name or version"
              continue
            fi
            
            # Check for version in git history
            TAG_NAME="${PKG_NAME}@${PKG_VERSION}"
            # Use the TAG_NAME directly without modification
            CLEAN_TAG_NAME="${TAG_NAME}"
            
            echo "Checking tag: ${CLEAN_TAG_NAME}"
            
            # Check if tag already exists
            if git tag -l | grep -q "^${CLEAN_TAG_NAME}$"; then
              echo "Tag ${CLEAN_TAG_NAME} already exists, skipping release"
              continue
            fi
            
            # Look for changelog
            CHANGELOG_PATH="${PKG_DIR}/CHANGELOG.md"
            RELEASE_NOTES=""
            
            if [[ -f "${CHANGELOG_PATH}" ]]; then
              # Extract the most recent changelog entry (between the first and second ## headings)
              RELEASE_NOTES="$(awk 'BEGIN{flag=0} /^## / {if (flag==1) {exit} flag=1; print; next} flag==1 {print}' "${CHANGELOG_PATH}")"
            fi
            
            if [[ -z "${RELEASE_NOTES}" ]]; then
              # If no changelog, generate one using our version info
              VERSION_OUTPUT="$(pnpm test-version --branch=main)"
              VERSION_INFO="$(echo "${VERSION_OUTPUT}" | grep "${PKG_NAME}:" | head -1)"
              
              if [[ -n "${VERSION_INFO}" ]]; then
                RELEASE_NOTES="Release ${PKG_NAME}@${PKG_VERSION}\n\n${VERSION_INFO}\n\nGenerated using custom versioning from commit history."
              else
                RELEASE_NOTES="Release ${PKG_NAME}@${PKG_VERSION}"
              fi
            fi
            
            echo "Creating tag and release for ${PKG_NAME} version ${PKG_VERSION}"
            
            # Create the tag
            git tag -a "${CLEAN_TAG_NAME}" -m "Release ${CLEAN_TAG_NAME}"
            git push origin "${CLEAN_TAG_NAME}"
            
            # Create GitHub release with extracted notes
            echo -e "${RELEASE_NOTES}" > release_notes.md
            gh release create "${CLEAN_TAG_NAME}" \
              --title "Release ${CLEAN_TAG_NAME}" \
              --notes-file release_notes.md
            
            # Update tracking variables
            CREATED_RELEASES="true"
            TAGS_CREATED="${TAGS_CREATED}${CLEAN_TAG_NAME}, "
            
            echo "Created release for ${PKG_NAME} version ${PKG_VERSION}"
          done
          
          # Trim trailing comma and space from tags list
          TAGS_CREATED="${TAGS_CREATED%, }"
          
          # Set outputs
          echo "created_releases=${CREATED_RELEASES}" >> "$GITHUB_OUTPUT"
          echo "tags_created=${TAGS_CREATED}" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Build the site for GitHub Pages
  build-site:
    name: Build Site for GitHub Pages
    needs: [test, create-release]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          registry-url: 'https://npm.pkg.github.com'
          
      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: '8.15.4'
          
      - name: Install dependencies
        run: pnpm install
          
      # Set GITHUB_PAGES environment variable to ensure correct base URL
      - name: Build for GitHub Pages
        run: |
          # First build the blorkpack package explicitly
          pnpm --filter=@littlecarlito/blorkpack build
          # Then build the portfolio with GitHub Pages flag
          GITHUB_PAGES=true pnpm --filter=@littlecarlito/portfolio build
          
      # Ensure _headers file is copied to the dist folder
      - name: Ensure _headers file for GitHub Pages
        run: |
          if [ -f "apps/portfolio/public/_headers" ]; then
            cp apps/portfolio/public/_headers apps/portfolio/dist/
            echo "Copied _headers file to dist folder"
          else
            echo "Warning: _headers file not found"
          fi
          
      # Create a .nojekyll file to disable Jekyll processing
      - name: Add .nojekyll file
        run: touch apps/portfolio/dist/.nojekyll
      
      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: apps/portfolio/dist

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        with:
          token: ${{ secrets.PACKAGE_TOKEN }} 

  # Report pipeline results (always runs after all jobs)
  report-results:
    name: Report Pipeline Results
    needs: [capture-trigger-info, build, test, create-release, build-site]
    if: always()
    runs-on: ubuntu-latest
    steps:
      # Determine overall workflow result
      - name: Determine workflow result
        id: workflow-result
        run: |
          # Check if any job failed
          if [[ "${{ needs.build.result }}" != "success" || 
                "${{ needs.test.result }}" != "success" || 
                "${{ needs.create-release.result }}" != "success" ||
                ("${{ needs.build-site.result }}" != "success" && "${{ needs.build-site.result }}" != "skipped") ]]; then
            echo "result=failure" >> "$GITHUB_OUTPUT"
            
            # Collect what failed for detailed reporting
            FAILED_JOBS=""
            [[ "${{ needs.build.result }}" != "success" ]] && FAILED_JOBS="${FAILED_JOBS}Build, "
            [[ "${{ needs.test.result }}" != "success" ]] && FAILED_JOBS="${FAILED_JOBS}Test, "
            [[ "${{ needs.create-release.result }}" != "success" ]] && FAILED_JOBS="${FAILED_JOBS}Release Creation, "
            [[ "${{ needs.build-site.result }}" != "success" && "${{ needs.build-site.result }}" != "skipped" ]] && FAILED_JOBS="${FAILED_JOBS}Site Deployment, "
            
            # Remove trailing comma and space
            FAILED_JOBS="${FAILED_JOBS%, }"
            echo "error_details=Jobs failed: ${FAILED_JOBS}" >> "$GITHUB_OUTPUT"
          else
            echo "result=success" >> "$GITHUB_OUTPUT"
          fi
          
          # Get trigger info from actor only
          echo "trigger_actor=${{ needs.capture-trigger-info.outputs.trigger_actor }}" >> "$GITHUB_OUTPUT"
          
      # Use the new action to report results
      - name: Checkout repository
        uses: actions/checkout@v4
        
      # Set details text based on result
      - name: Set details text
        id: details_text
        run: |
          if [[ -n "${{ steps.workflow-result.outputs.error_details }}" ]]; then
            echo "content=${{ steps.workflow-result.outputs.error_details }}" >> "$GITHUB_OUTPUT"
          else
            echo "content=Successful run" >> "$GITHUB_OUTPUT"
          fi
        
      - name: Report pipeline results
        uses: ./.github/actions/report-workflow-results
        with:
          workflow-name: 'Main Pipeline'
          result: ${{ steps.workflow-result.outputs.result }}
          branch: main
          summary: >-
            Main Pipeline ${{ steps.workflow-result.outputs.result }}. 
            Triggered by ${{ needs.capture-trigger-info.outputs.trigger_actor }}. 
            Details ${{ steps.details_text.outputs.content }}.
          source: 'dispatch'
          discord-webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          github-token: ${{ secrets.PR_CREATION_TOKEN }} 