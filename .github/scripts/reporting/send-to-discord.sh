#!/bin/bash
set -e

# Script to send pipeline execution results to Discord via webhook
# Uses the summary JSON generated by generate-summary.sh

# Initialize variables with default values
SUMMARY_FILE="./summary.json"
WEBHOOK_URL=""

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --summary-file)
      SUMMARY_FILE="$2"
      shift 2
      ;;
    --webhook-url)
      WEBHOOK_URL="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Validate required arguments
if [ -z "$WEBHOOK_URL" ]; then
  echo "ERROR: webhook-url is required"
  exit 1
fi

if [ ! -f "$SUMMARY_FILE" ]; then
  echo "ERROR: Summary file not found at $SUMMARY_FILE"
  exit 1
fi

# Extract values from summary JSON
WORKFLOW_NAME=$(jq -r '.workflow.name' "$SUMMARY_FILE")
WORKFLOW_RESULT=$(jq -r '.workflow.result' "$SUMMARY_FILE")
WORKFLOW_URL=$(jq -r '.workflow.url' "$SUMMARY_FILE")
REPOSITORY=$(jq -r '.repository' "$SUMMARY_FILE")
TRIGGER_BRANCH=$(jq -r '.trigger.branch' "$SUMMARY_FILE")
SHORT_SHA=$(jq -r '.trigger.short_sha' "$SUMMARY_FILE")
STATUS_EMOJI=$(jq -r '.display.status_emoji' "$SUMMARY_FILE")
COLOR=$(jq -r '.display.color' "$SUMMARY_FILE" | sed 's/0x//')

# Get additional details if present
TRIGGER_DETAILS=$(jq -r '.trigger.details // ""' "$SUMMARY_FILE")
TRIGGER_SOURCE=$(jq -r '.trigger.source // ""' "$SUMMARY_FILE")
TRIGGER_INFO=$(jq -r '.trigger.info // ""' "$SUMMARY_FILE")

# Convert hex color to decimal (Discord requires decimal)
COLOR_DEC=$((16#$COLOR))

# Create a concise, non-repetitive description
DESCRIPTION="**Result:** ${WORKFLOW_RESULT}\n**Repository:** ${REPOSITORY}"

# Add branch info - prioritize source branch if available
if [ -n "$TRIGGER_SOURCE" ] && [ "$TRIGGER_SOURCE" != "null" ]; then
  DESCRIPTION="${DESCRIPTION}\n**Branch:** ${TRIGGER_SOURCE}"
elif [ -n "$TRIGGER_BRANCH" ]; then
  DESCRIPTION="${DESCRIPTION}\n**Branch:** ${TRIGGER_BRANCH}"
fi

# Add commit info
DESCRIPTION="${DESCRIPTION}\n**Commit:** ${SHORT_SHA}"

# Add trigger details if available and not redundant
if [ -n "$TRIGGER_DETAILS" ] && [ "$TRIGGER_DETAILS" != "null" ]; then
  # Only add if it contains unique information (not already in description)
  if ! echo "$DESCRIPTION" | grep -q "$TRIGGER_DETAILS"; then
    DESCRIPTION="${DESCRIPTION}\n**Details:** ${TRIGGER_DETAILS}"
  fi
fi

# For failures, try to capture more details about what failed
FIELDS_JSON=""
if [ "$WORKFLOW_RESULT" == "failure" ] || [ "$WORKFLOW_RESULT" == "partial" ]; then
  # Extract failure information if available
  FAILED_STEP=$(jq -r '.failure.step // ""' "$SUMMARY_FILE")
  ERROR_MESSAGE=$(jq -r '.failure.message // ""' "$SUMMARY_FILE")
  SKIPPED_STEPS=$(jq -r '.failure.skipped_steps // ""' "$SUMMARY_FILE")
  
  # Add failed step information
  if [ -n "$FAILED_STEP" ] && [ "$FAILED_STEP" != "null" ]; then
    FIELDS_JSON="${FIELDS_JSON}, {
      \"name\": \"❌ Failed Step\",
      \"value\": \"${FAILED_STEP}\",
      \"inline\": false
    }"
  else 
    # If specific step information isn't available, provide generic message
    if [ "$WORKFLOW_RESULT" == "failure" ]; then
      FIELDS_JSON="${FIELDS_JSON}, {
        \"name\": \"❌ Failure Information\",
        \"value\": \"The workflow failed. Check the logs for details.\",
        \"inline\": false
      }"
    else
      FIELDS_JSON="${FIELDS_JSON}, {
        \"name\": \"⚠️ Partial Success\",
        \"value\": \"Some steps completed but others had issues.\",
        \"inline\": false
      }"
    fi
  fi
  
  # Add error message if available
  if [ -n "$ERROR_MESSAGE" ] && [ "$ERROR_MESSAGE" != "null" ]; then
    # Truncate very long error messages
    if [ ${#ERROR_MESSAGE} -gt 300 ]; then
      ERROR_MESSAGE="${ERROR_MESSAGE:0:297}..."
    fi
    
    FIELDS_JSON="${FIELDS_JSON}, {
      \"name\": \"Error Details\",
      \"value\": \"${ERROR_MESSAGE}\",
      \"inline\": false
    }"
  fi
  
  # Add skipped steps if available
  if [ -n "$SKIPPED_STEPS" ] && [ "$SKIPPED_STEPS" != "null" ]; then
    FIELDS_JSON="${FIELDS_JSON}, {
      \"name\": \"⏭️ Skipped Steps\",
      \"value\": \"${SKIPPED_STEPS}\",
      \"inline\": false
    }"
  fi
  
  # If the fields JSON starts with a comma, remove it
  FIELDS_JSON=$(echo "$FIELDS_JSON" | sed 's/^, //')
fi

# Create Discord embed JSON
EMBED_JSON=$(cat <<EOF
{
  "embeds": [
    {
      "title": "${STATUS_EMOJI} ${WORKFLOW_NAME}",
      "description": "${DESCRIPTION}",
      "color": ${COLOR_DEC},
      "url": "${WORKFLOW_URL}",
      "fields": [${FIELDS_JSON}],
      "footer": {
        "text": "GitHub Actions • $(date +'%Y-%m-%d %H:%M UTC')"
      }
    }
  ]
}
EOF
)

# Debug info (avoid leaking webhook URL)
echo "Sending webhook to Discord..."
echo "Workflow: $WORKFLOW_NAME"
echo "Result: $WORKFLOW_RESULT"
echo "Embedding JSON payload (sensitive data omitted)..."

# Send the webhook
curl -s -H "Content-Type: application/json" -d "$EMBED_JSON" "$WEBHOOK_URL"

# Check curl status
if [ $? -eq 0 ]; then
  echo "Successfully sent notification to Discord!"
else
  echo "Failed to send notification to Discord."
  exit 1
fi

exit 0 